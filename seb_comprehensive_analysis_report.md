# Safe Exam Browser (SEB) 総合技術分析レポート

## はじめに

本レポートは、Safe Exam Browser (SEB) の通信プロトコル、セキュリティモデル、およびクライアント側の実装に関する一連の調査結果を統合し、その技術的全体像を包括的に解説するものである。分析は、提供されたHTTPログとSEBのmacOS版クライアントのソースコードに基づいている。

---

## 第1章: プロトコル概要 - 通信フローの解読

初期のHTTPログ分析から、SEBが試験セッションを開始する際の基本的な通信フローは以下の3段階で構成されることが明らかになった。

1.  **段階1: 標準ブラウザによる設定情報の取得**
    *   **アクション:** ユーザーがLMS（Moodle等）上の試験開始リンクをクリックする。
    *   **通信:** 通常のブラウザ（例: Safari）が、LMSの特定エンドポイント（例: `/seb/config.php`）にリクエストを送信する。
    *   **サーバー応答:** サーバーは `Content-Type: application/seb` と共に、試験設定が記述された `.seb` ファイル（実体はplist形式のXML）を返す。

2.  **段階2: SEBクライアントによる設定の再取得**
    *   **アクション:** OSが `.seb` ファイルをSEBアプリケーションで開く。
    *   **通信:** 起動したSEBクライアント本体が、自身の `User-Agent`（例: `SafeExamBrowser/...`）を用いて、段階1と全く同じURLに再度リクエストを行う。これは、通信セッションのコンテキストをSEB自身に移すための重要なステップである。
    *   **サーバー応答:** 段階1と同一の `.seb` ファイルを返す。

3.  **段階3: SEB内セキュアブラウザによる試験ページへのアクセス**
    *   **アクション:** SEBは、取得した設定ファイル内の `startURL` に指定された試験ページへアクセスする。
    *   **通信:** このリクエストには、2つの重要なカスタムヘッダ `X-SafeExamBrowser-RequestHash` と `X-SafeExamBrowser-ConfigKeyHash` が付与される。`User-Agent` もSEB独自のフォーマットに書き換えられる。
    *   **サーバー応答:** LMS側は、これらのヘッダの存在を確認し、正当なSEBからのアクセスと判断して試験ページのHTMLを返す。

---

## 第2章: 設定ファイルの処理 - `.seb` はどのように解釈されるか

SEBの動作は、すべて `.seb` 設定ファイルによって規定される。このファイルの処理は、クライアントセキュリティの第一歩である。

*   **担当コンポーネント:** `Classes/ConfigFiles/SEBConfigFileManager.m`
*   **処理フロー:**
    1.  **受信とデコード:** SEBは、OSから渡された、あるいはHTTPでダウンロードした `.seb` ファイルのデータ（`NSData`）を受け取る。このデータは通常、**二重にgzip圧縮**されており（全体がgzip、さらに暗号化ペイロードがgzip）、SEBはこれを段階的に伸長する。
    2.  **プレフィックス判定と復号:** 伸長後のデータの先頭4バイトは、暗号化形式を示すプレフィックスとなっている。
        *   `plnd` または `<?xm`: データは暗号化されていない。
        *   `pswd`: パスワードで暗号化されている。SEBはユーザーにパスワード入力を求め、`RNCryptor` ライブラリを用いて復号する。
    3.  **パース:** 完全に復号・伸長されたデータはplist(XML)形式であり、`NSPropertyListSerialization` を用いて `NSDictionary` オブジェクトに変換される。
    4.  **設定の適用:** パースされた `NSDictionary` の内容が `NSUserDefaults` に書き込まれ、SEB全体の動作設定が更新される。このタイミングが、次章で述べるセキュリティキー再計算のトリガーとなる。

---

## 第3章: セキュリティキーの生成 - 2つのハッシュの根源

SEBの信頼性の中核をなす2つのヘッダ値は、それぞれ異なる中間キー `configKey` と `browserExamKey` から動的に計算される。これらのキーの生成ロジックは極めて重要である。

*   **担当コンポーネント:** `Classes/Cryptography/SEBCryptor.m`

### 3.1. `configKey` - 設定ファイルの「指紋」

*   **目的:** 設定ファイルそのものの完全性（改ざんされていないこと）を証明する。
*   **計算ロジック:**
    1.  SEBの全設定項目を、特定のルール（キーのアルファベット順ソートなど）に従って**JSON文字列にシリアライズ**する。この変換ロジックはSEB独自のものであり、再現にはリバースエンジニアリングが必須。
    2.  生成されたJSON文字列に対し、**単純なSHA-256ハッシュ**を計算する。
    3.  この結果（32バイトのバイナリ）が `configKey` となる。
*   **特徴:** このキーの計算にはソルトが不要なため、**同じ設定ファイルからは必ず同じ `configKey` が生成される。** これにより、サーバー側は自身が配布した設定から期待される `configKey` を事前に計算しておくことが可能になる。

### 3.2. `browserExamKey` - クライアントインスタンスの「証明書」

*   **目的:** 特定のクライアントインスタンスを一意に識別し、セッションの正当性を担保する。
*   **計算ロジック:**
    1.  **ソルトの取得/生成:**
        *   まず、設定ファイル内から `org_safeexambrowser_SEB_examKeySalt` というキーでソルトを探す。
        *   **存在しない場合、SEBは内部で暗号学的に安全な32バイトのランダムなソルトを新規に生成し、設定に加える。** これが、クライアントごとにキーを一意にするための核心的な仕組みである。
    2.  SEBの全設定項目を **plist(XML)形式にシリアライズ**する。
    3.  ステップ1で得られたソルトを秘密鍵として、ステップ2のplistデータに対し **HMAC-SHA256ハッシュ**を計算する。
    4.  この結果（32バイトのバイナリ）が `browserExamKey` となる。

---

## 第4章: HTTPリクエストの構築 - SEBの「証票」の提示

計算されたキーを使い、実際のリクエストを改変するプロセス。

*   **担当コンポーネント:** `Classes/BrowserComponents/SEBBrowserController.m`
*   **中心メソッド:** `- (NSURLRequest *)modifyRequest:(NSURLRequest *)request`
*   **処理フロー:**
    1.  WebViewで発生したすべてのリクエストがこのメソッドに渡される。
    2.  メソッドはまず、リクエストを `NSMutableURLRequest` としてコピーする。
    3.  設定 `sendBrowserExamKey` が `true` の場合、以下の処理を実行する。
        a. **`X-SafeExamBrowser-RequestHash` の生成:** `リクエストURL` と、現在保持している `browserExamKey` の16進数文字列を連結し、その結果にSHA-256ハッシュをかけてヘッダにセットする。
        b. **`X-SafeExamBrowser-ConfigKeyHash` の生成:** `リクエストURL` と、現在保持している `configKey` の16進数文字列を連結し、その結果にSHA-256ハッシュをかけてヘッダにセットする。
    4.  **`User-Agent` の書き換え:** `- (NSString*)customSEBUserAgent` メソッドを呼び出し、設定に応じたカスタムUser-Agent（例: `... SEB/3.5 ...`）を生成してヘッダを上書きする。
    5.  ヘッダの追加・改変が完了した新しいリクエストを返す。

---

## 第5章: JavaScript連携と高度な検証

SEBのセキュリティは、HTTPヘッダの付与だけで完結しているわけではない。Webページ内のJavaScriptとの連携により、より動的で堅牢な検証メカニズムを構築している。

*   **担当コンポーネント:** `Classes/BrowserComponents/SEBAbstractModernWebView.swift`
*   **仕組み:**
    1.  **APIの注入:** SEBはすべてのWebページに対し、`window.SafeExamBrowser` というグローバルオブジェクトを注入する。
    2.  **オンデマンドのキー提供:** このオブジェクトには `security.updateKeys()` という関数が含まれている。LMSのJavaScriptがこの関数を呼び出すと、SEBはネイティブ側でその時点の `browserExamKey` と `configKey` を計算し、JavaScript上の `window.SafeExamBrowser.security.browserExamKey` と `security.configKey` の値を更新する。
    3.  **サーバーサイド検証:** これにより、LMSはJavaScriptを介してクライアントから信頼できる `configKey` を取得できる。サーバーは、自身が配布した設定から計算した `configKey` の期待値と、クライアントから送られてきた値を比較することで、**クライアントが正しい設定ファイルを使用していることを、ソルト情報なしに検証できる。**

## 第6章: 総合結論 - SEBのセキュリティモデルと偽装の実現性

SEBのセキュリティモデルは、複数のメカニズムを組み合わせた多層防御となっている。

1.  **OSレベルのロックダウン:** SEBの最も基本的なセキュリティ機能（本レポートの対象外）。
2.  **リクエストヘッダによる識別:** `X-SafeExamBrowser-*` ヘッダの存在により、リクエストがSEBから来たものであることを示す。
3.  **`configKey` による設定整合性の検証:** サーバーは、JavaScript API経由で `configKey` を取得・比較することで、クライアントが改ざんされていない正しい設定を使用していることを確認できる。
4.  **`browserExamKey` によるクライアントの一意性の担保:** クライアント側で生成されるランダムソルトにより、`browserExamKey` とそれから派生する `RequestHash` はクライアントごとにユニークとなる。これは、将来的にチャレンジ・レスポンスのような、より高度なクライアント認証を実装するための布石と考えられる。

これらの分析から、Chrome拡張機能による**偽装の実現性**について、以下の結論を導き出した。

*   **理論上の可能性:** 偽装が成功するには、`configKey` の複雑な計算ロジックを完全に再現し、かつJavaScript APIの呼び出しに正しく応答する必要がある。これは極めて困難だが、不可能ではない。
*   **現実的な困難性:** `configKey` の生成ロジックはSEBの実装に強く依存しており、リバースエンジニアリングには多大な労力を要する。また、LMSが `browserExamKey` を利用した未発見の追加検証を行っている場合、クライアント側で生成されるソルトのランダム性により、偽装は原理的に不可能となる。

総じて、SEBの通信プロトコルは、単純なヘッダ偽装では容易に突破できない、巧妙かつ堅牢な設計になっていると言える。
