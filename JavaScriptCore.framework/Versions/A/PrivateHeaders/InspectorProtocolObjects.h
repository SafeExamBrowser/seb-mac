/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from CombinedDomains.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#pragma once

#include "InspectorProtocolTypes.h"
#include <wtf/JSONValues.h>
#include <wtf/Optional.h>
#include <wtf/text/WTFString.h>

namespace Inspector {



namespace Protocol {

// Versions.
namespace Audit {
static constexpr unsigned VERSION = 3;
} // Audit

namespace Recording {
static constexpr unsigned VERSION = 1;
} // Recording
// End of versions.


// Forward declarations.
namespace Animation {
class Animation;
class Effect;
class Keyframe;
class TrackingUpdate;
enum class AnimationState;
enum class PlaybackDirection;
enum class FillMode;
} // Animation

namespace ApplicationCache {
class ApplicationCacheResource;
class ApplicationCache;
class FrameWithManifest;
} // ApplicationCache

namespace Browser {
class Extension;
} // Browser

#if defined(ENABLE_RESOURCE_USAGE) && ENABLE_RESOURCE_USAGE
namespace CPUProfiler {
class ThreadInfo;
class Event;
} // CPUProfiler
#endif // defined(ENABLE_RESOURCE_USAGE) && ENABLE_RESOURCE_USAGE

namespace CSS {
class CSSStyleId;
class CSSRuleId;
class PseudoIdMatches;
class InheritedStyleEntry;
class RuleMatch;
class CSSSelector;
class SelectorList;
class CSSStyleAttribute;
class CSSStyleSheetHeader;
class CSSStyleSheetBody;
class CSSRule;
class SourceRange;
class ShorthandEntry;
class CSSPropertyInfo;
class CSSComputedStyleProperty;
class CSSStyle;
class CSSProperty;
class Grouping;
enum class StyleSheetOrigin;
enum class PseudoId;
enum class CSSPropertyStatus;
} // CSS

namespace Canvas {
class ContextAttributes;
class Canvas;
#if (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
class ShaderProgram;
#endif // (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
enum class ContextType;
#if (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
enum class ProgramType;
#endif // (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
#if (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
enum class ShaderType;
#endif // (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
} // Canvas

namespace Console {
class Channel;
class ConsoleMessage;
class CallFrame;
class StackTrace;
enum class ChannelSource;
enum class ChannelLevel;
} // Console

namespace DOM {
class Node;
class DataBinding;
class EventListener;
class AccessibilityProperties;
class RGBAColor;
class HighlightConfig;
enum class PseudoType;
enum class ShadowRootType;
enum class CustomElementState;
enum class LiveRegionRelevant;
} // DOM

namespace DOMDebugger {
enum class DOMBreakpointType;
enum class EventBreakpointType;
} // DOMDebugger

namespace DOMStorage {
class StorageId;
} // DOMStorage

namespace Database {
class Database;
class Error;
} // Database

namespace Debugger {
class Location;
class BreakpointAction;
class BreakpointOptions;
class FunctionDetails;
class CallFrame;
class Scope;
class ProbeSample;
class AssertPauseReason;
class BreakpointPauseReason;
class CSPViolationPauseReason;
} // Debugger

namespace GenericTypes {
class SearchMatch;
} // GenericTypes

namespace Heap {
class GarbageCollection;
} // Heap

#if defined(ENABLE_INDEXED_DATABASE) && ENABLE_INDEXED_DATABASE
namespace IndexedDB {
class DatabaseWithObjectStores;
class ObjectStore;
class ObjectStoreIndex;
class Key;
class KeyRange;
class DataEntry;
class KeyPath;
} // IndexedDB
#endif // defined(ENABLE_INDEXED_DATABASE) && ENABLE_INDEXED_DATABASE

namespace LayerTree {
class IntRect;
class Layer;
class CompositingReasons;
} // LayerTree

#if defined(ENABLE_RESOURCE_USAGE) && ENABLE_RESOURCE_USAGE
namespace Memory {
class Event;
class CategoryData;
} // Memory
#endif // defined(ENABLE_RESOURCE_USAGE) && ENABLE_RESOURCE_USAGE

namespace Network {
class Headers;
class ResourceTiming;
class Request;
class Response;
class Metrics;
class WebSocketRequest;
class WebSocketResponse;
class WebSocketFrame;
class CachedResource;
class Initiator;
enum class NetworkStage;
enum class ResourceErrorType;
} // Network

namespace Page {
class Frame;
class FrameResource;
class FrameResourceTree;
class SearchResult;
class Cookie;
enum class Setting;
enum class ResourceType;
enum class CoordinateSystem;
enum class CookieSameSitePolicy;
#if (defined(ENABLE_DARK_MODE_CSS) && ENABLE_DARK_MODE_CSS) || (defined(HAVE_OS_DARK_MODE_SUPPORT) && HAVE_OS_DARK_MODE_SUPPORT)
enum class Appearance;
#endif // (defined(ENABLE_DARK_MODE_CSS) && ENABLE_DARK_MODE_CSS) || (defined(HAVE_OS_DARK_MODE_SUPPORT) && HAVE_OS_DARK_MODE_SUPPORT)
} // Page

namespace Recording {
class InitialState;
class Frame;
class Recording;
enum class Type;
enum class Initiator;
} // Recording

namespace Runtime {
class RemoteObject;
class ObjectPreview;
class PropertyPreview;
class EntryPreview;
class CollectionEntry;
class PropertyDescriptor;
class InternalPropertyDescriptor;
class CallArgument;
class ExecutionContextDescription;
class ErrorRange;
class StructureDescription;
class TypeSet;
class TypeDescription;
class TypeLocation;
class BasicBlock;
enum class ExecutionContextType;
enum class SyntaxErrorType;
} // Runtime

namespace ScriptProfiler {
class Event;
class ExpressionLocation;
class StackFrame;
class StackTrace;
class Samples;
enum class EventType;
} // ScriptProfiler

namespace Security {
class Connection;
class Certificate;
class Security;
} // Security

#if defined(ENABLE_SERVICE_WORKER) && ENABLE_SERVICE_WORKER
namespace ServiceWorker {
class Configuration;
} // ServiceWorker
#endif // defined(ENABLE_SERVICE_WORKER) && ENABLE_SERVICE_WORKER

namespace Target {
class TargetInfo;
} // Target

namespace Timeline {
class TimelineEvent;
enum class EventType;
enum class Instrument;
} // Timeline
// End of forward declarations.


// Typedefs.
namespace Animation {
/* Unique Web Animation identifier. */
using AnimationId = String;
} // Animation

namespace Browser {
/* Unique extension identifier. */
using ExtensionId = String;
} // Browser

namespace CSS {
using StyleSheetId = String;
} // CSS

namespace Canvas {
/* Unique canvas identifier. */
using CanvasId = String;
#if (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
/* Unique shader program identifier. */
using ProgramId = String;
#endif // (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
} // Canvas

namespace DOM {
/* Unique DOM node identifier. */
using NodeId = int;
/* Unique event listener identifier. */
using EventListenerId = int;
/* An array of quad vertices, x immediately followed by y for each point, points clock-wise. */
using Quad = JSON::ArrayOf<double>;
} // DOM

namespace DOMStorage {
/* DOM Storage item. */
using Item = JSON::ArrayOf<String>;
} // DOMStorage

namespace Database {
/* Unique identifier of Database object. */
using DatabaseId = String;
} // Database

namespace Debugger {
/* Breakpoint identifier. */
using BreakpointId = String;
/* Breakpoint action identifier. */
using BreakpointActionIdentifier = int;
/* Unique script identifier. */
using ScriptId = String;
/* Call frame identifier. */
using CallFrameId = String;
} // Debugger

namespace Heap {
/* JavaScriptCore HeapSnapshot JSON data. */
using HeapSnapshotData = String;
} // Heap

namespace LayerTree {
/* Unique RenderLayer identifier. */
using LayerId = String;
/* Unique PseudoElement identifier. */
using PseudoElementId = String;
} // LayerTree

namespace Network {
/* Unique loader identifier. */
using LoaderId = String;
/* Unique frame identifier. */
using FrameId = String;
/* Unique request identifier. */
using RequestId = String;
/* Elapsed seconds since frontend connected. */
using Timestamp = double;
/* Number of seconds since epoch. */
using Walltime = double;
} // Network

namespace Runtime {
/* Unique object identifier. */
using RemoteObjectId = String;
/* Id of an execution context. */
using ExecutionContextId = int;
} // Runtime
// End of typedefs.

namespace Helpers {

JS_EXPORT_PRIVATE String getEnumConstantValue(int code);

template<typename T> String getEnumConstantValue(T enumValue)
{
    return getEnumConstantValue(static_cast<int>(enumValue));
}

} // namespace Helpers

namespace Animation {

enum class AnimationState {
    Ready = 0,
    Delayed = 1,
    Active = 2,
    Canceled = 3,
    Done = 4,
}; // enum class AnimationState

enum class PlaybackDirection {
    Normal = 5,
    Reverse = 6,
    Alternate = 7,
    AlternateReverse = 8,
}; // enum class PlaybackDirection

enum class FillMode {
    None = 9,
    Forwards = 10,
    Backwards = 11,
    Both = 12,
    Auto = 13,
}; // enum class FillMode

class Animation final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AnimationIdSet = 1 << 0,
        AllFieldsSet = (AnimationIdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Animation*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Animation;
    public:

        Builder<STATE | AnimationIdSet>& setAnimationId(const String& in_animationId)
        {
            COMPILE_ASSERT(!(STATE & AnimationIdSet), property_animationId_already_set);
            m_result->setString("animationId"_s, in_animationId);
            return castState<AnimationIdSet>();
        }

        Ref<Animation> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Animation) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Animation>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Animation> result = Animation::create()
     *     .setAnimationId(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setName(const String& in_opt_name)
    {
        JSON::ObjectBase::setString("name"_s, in_opt_name);
    }

    void setCssAnimationName(const String& in_opt_cssAnimationName)
    {
        JSON::ObjectBase::setString("cssAnimationName"_s, in_opt_cssAnimationName);
    }

    void setCssTransitionProperty(const String& in_opt_cssTransitionProperty)
    {
        JSON::ObjectBase::setString("cssTransitionProperty"_s, in_opt_cssTransitionProperty);
    }

    void setEffect(Ref<Protocol::Animation::Effect>&& in_opt_effect)
    {
        JSON::ObjectBase::setObject("effect"_s, WTFMove(in_opt_effect));
    }

    void setBacktrace(Ref<JSON::ArrayOf<Protocol::Console::CallFrame>>&& in_opt_backtrace)
    {
        JSON::ObjectBase::setArray("backtrace"_s, WTFMove(in_opt_backtrace));
    }
};

class Effect final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Effect*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Effect;
    public:

        Ref<Effect> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Effect) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Effect>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Effect> result = Effect::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setStartDelay(double in_opt_startDelay)
    {
        JSON::ObjectBase::setDouble("startDelay"_s, in_opt_startDelay);
    }

    void setEndDelay(double in_opt_endDelay)
    {
        JSON::ObjectBase::setDouble("endDelay"_s, in_opt_endDelay);
    }

    void setIterationCount(double in_opt_iterationCount)
    {
        JSON::ObjectBase::setDouble("iterationCount"_s, in_opt_iterationCount);
    }

    void setIterationStart(double in_opt_iterationStart)
    {
        JSON::ObjectBase::setDouble("iterationStart"_s, in_opt_iterationStart);
    }

    void setIterationDuration(double in_opt_iterationDuration)
    {
        JSON::ObjectBase::setDouble("iterationDuration"_s, in_opt_iterationDuration);
    }

    void setTimingFunction(const String& in_opt_timingFunction)
    {
        JSON::ObjectBase::setString("timingFunction"_s, in_opt_timingFunction);
    }

    void setPlaybackDirection(Protocol::Animation::PlaybackDirection in_opt_playbackDirection)
    {
        JSON::ObjectBase::setString("playbackDirection"_s, Protocol::Helpers::getEnumConstantValue(in_opt_playbackDirection));
    }

    void setFillMode(Protocol::Animation::FillMode in_opt_fillMode)
    {
        JSON::ObjectBase::setString("fillMode"_s, Protocol::Helpers::getEnumConstantValue(in_opt_fillMode));
    }

    void setKeyframes(Ref<JSON::ArrayOf<Protocol::Animation::Keyframe>>&& in_opt_keyframes)
    {
        JSON::ObjectBase::setArray("keyframes"_s, WTFMove(in_opt_keyframes));
    }
};

class Keyframe final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        OffsetSet = 1 << 0,
        AllFieldsSet = (OffsetSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Keyframe*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Keyframe;
    public:

        Builder<STATE | OffsetSet>& setOffset(double in_offset)
        {
            COMPILE_ASSERT(!(STATE & OffsetSet), property_offset_already_set);
            m_result->setDouble("offset"_s, in_offset);
            return castState<OffsetSet>();
        }

        Ref<Keyframe> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Keyframe) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Keyframe>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Keyframe> result = Keyframe::create()
     *     .setOffset(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setEasing(const String& in_opt_easing)
    {
        JSON::ObjectBase::setString("easing"_s, in_opt_easing);
    }

    void setStyle(const String& in_opt_style)
    {
        JSON::ObjectBase::setString("style"_s, in_opt_style);
    }
};

class TrackingUpdate final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TrackingAnimationIdSet = 1 << 0,
        AnimationStateSet = 1 << 1,
        AllFieldsSet = (TrackingAnimationIdSet | AnimationStateSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*TrackingUpdate*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class TrackingUpdate;
    public:

        Builder<STATE | TrackingAnimationIdSet>& setTrackingAnimationId(const String& in_trackingAnimationId)
        {
            COMPILE_ASSERT(!(STATE & TrackingAnimationIdSet), property_trackingAnimationId_already_set);
            m_result->setString("trackingAnimationId"_s, in_trackingAnimationId);
            return castState<TrackingAnimationIdSet>();
        }

        Builder<STATE | AnimationStateSet>& setAnimationState(Protocol::Animation::AnimationState in_animationState)
        {
            COMPILE_ASSERT(!(STATE & AnimationStateSet), property_animationState_already_set);
            m_result->setString("animationState"_s, Protocol::Helpers::getEnumConstantValue(in_animationState));
            return castState<AnimationStateSet>();
        }

        Ref<TrackingUpdate> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(TrackingUpdate) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<TrackingUpdate>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<TrackingUpdate> result = TrackingUpdate::create()
     *     .setTrackingAnimationId(...)
     *     .setAnimationState(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setNodeId(int in_opt_nodeId)
    {
        JSON::ObjectBase::setInteger("nodeId"_s, in_opt_nodeId);
    }

    void setAnimationName(const String& in_opt_animationName)
    {
        JSON::ObjectBase::setString("animationName"_s, in_opt_animationName);
    }

    void setTransitionProperty(const String& in_opt_transitionProperty)
    {
        JSON::ObjectBase::setString("transitionProperty"_s, in_opt_transitionProperty);
    }
};

} // Animation

namespace ApplicationCache {

/* Detailed application cache resource information. */
class ApplicationCacheResource final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        SizeSet = 1 << 1,
        TypeSet = 1 << 2,
        AllFieldsSet = (UrlSet | SizeSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ApplicationCacheResource*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ApplicationCacheResource;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& in_url)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url"_s, in_url);
            return castState<UrlSet>();
        }

        Builder<STATE | SizeSet>& setSize(int in_size)
        {
            COMPILE_ASSERT(!(STATE & SizeSet), property_size_already_set);
            m_result->setInteger("size"_s, in_size);
            return castState<SizeSet>();
        }

        Builder<STATE | TypeSet>& setType(const String& in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, in_type);
            return castState<TypeSet>();
        }

        Ref<ApplicationCacheResource> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ApplicationCacheResource) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<ApplicationCacheResource>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ApplicationCacheResource> result = ApplicationCacheResource::create()
     *     .setUrl(...)
     *     .setSize(...)
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Detailed application cache information. */
class ApplicationCache final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ManifestURLSet = 1 << 0,
        SizeSet = 1 << 1,
        CreationTimeSet = 1 << 2,
        UpdateTimeSet = 1 << 3,
        ResourcesSet = 1 << 4,
        AllFieldsSet = (ManifestURLSet | SizeSet | CreationTimeSet | UpdateTimeSet | ResourcesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ApplicationCache*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ApplicationCache;
    public:

        Builder<STATE | ManifestURLSet>& setManifestURL(const String& in_manifestURL)
        {
            COMPILE_ASSERT(!(STATE & ManifestURLSet), property_manifestURL_already_set);
            m_result->setString("manifestURL"_s, in_manifestURL);
            return castState<ManifestURLSet>();
        }

        Builder<STATE | SizeSet>& setSize(double in_size)
        {
            COMPILE_ASSERT(!(STATE & SizeSet), property_size_already_set);
            m_result->setDouble("size"_s, in_size);
            return castState<SizeSet>();
        }

        Builder<STATE | CreationTimeSet>& setCreationTime(double in_creationTime)
        {
            COMPILE_ASSERT(!(STATE & CreationTimeSet), property_creationTime_already_set);
            m_result->setDouble("creationTime"_s, in_creationTime);
            return castState<CreationTimeSet>();
        }

        Builder<STATE | UpdateTimeSet>& setUpdateTime(double in_updateTime)
        {
            COMPILE_ASSERT(!(STATE & UpdateTimeSet), property_updateTime_already_set);
            m_result->setDouble("updateTime"_s, in_updateTime);
            return castState<UpdateTimeSet>();
        }

        Builder<STATE | ResourcesSet>& setResources(Ref<JSON::ArrayOf<Protocol::ApplicationCache::ApplicationCacheResource>>&& in_resources)
        {
            COMPILE_ASSERT(!(STATE & ResourcesSet), property_resources_already_set);
            m_result->setArray("resources"_s, WTFMove(in_resources));
            return castState<ResourcesSet>();
        }

        Ref<ApplicationCache> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ApplicationCache) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<ApplicationCache>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ApplicationCache> result = ApplicationCache::create()
     *     .setManifestURL(...)
     *     .setSize(...)
     *     .setCreationTime(...)
     *     .setUpdateTime(...)
     *     .setResources(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Frame identifier - manifest URL pair. */
class FrameWithManifest final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        FrameIdSet = 1 << 0,
        ManifestURLSet = 1 << 1,
        StatusSet = 1 << 2,
        AllFieldsSet = (FrameIdSet | ManifestURLSet | StatusSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*FrameWithManifest*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class FrameWithManifest;
    public:

        Builder<STATE | FrameIdSet>& setFrameId(const String& in_frameId)
        {
            COMPILE_ASSERT(!(STATE & FrameIdSet), property_frameId_already_set);
            m_result->setString("frameId"_s, in_frameId);
            return castState<FrameIdSet>();
        }

        Builder<STATE | ManifestURLSet>& setManifestURL(const String& in_manifestURL)
        {
            COMPILE_ASSERT(!(STATE & ManifestURLSet), property_manifestURL_already_set);
            m_result->setString("manifestURL"_s, in_manifestURL);
            return castState<ManifestURLSet>();
        }

        Builder<STATE | StatusSet>& setStatus(int in_status)
        {
            COMPILE_ASSERT(!(STATE & StatusSet), property_status_already_set);
            m_result->setInteger("status"_s, in_status);
            return castState<StatusSet>();
        }

        Ref<FrameWithManifest> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(FrameWithManifest) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<FrameWithManifest>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<FrameWithManifest> result = FrameWithManifest::create()
     *     .setFrameId(...)
     *     .setManifestURL(...)
     *     .setStatus(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // ApplicationCache

namespace Browser {

/* Information about an extension. */
class Extension final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ExtensionIdSet = 1 << 0,
        NameSet = 1 << 1,
        AllFieldsSet = (ExtensionIdSet | NameSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Extension*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Extension;
    public:

        Builder<STATE | ExtensionIdSet>& setExtensionId(const String& in_extensionId)
        {
            COMPILE_ASSERT(!(STATE & ExtensionIdSet), property_extensionId_already_set);
            m_result->setString("extensionId"_s, in_extensionId);
            return castState<ExtensionIdSet>();
        }

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Ref<Extension> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Extension) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Extension>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Extension> result = Extension::create()
     *     .setExtensionId(...)
     *     .setName(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // Browser

#if defined(ENABLE_RESOURCE_USAGE) && ENABLE_RESOURCE_USAGE
namespace CPUProfiler {

/* CPU usage for an individual thread. */
class ThreadInfo final : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating ThreadInfo.
    enum class Type {
        Main = 14,
        WebKit = 15,
    }; // enum class Type

    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        UsageSet = 1 << 1,
        AllFieldsSet = (NameSet | UsageSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ThreadInfo*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ThreadInfo;
    public:

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Builder<STATE | UsageSet>& setUsage(double in_usage)
        {
            COMPILE_ASSERT(!(STATE & UsageSet), property_usage_already_set);
            m_result->setDouble("usage"_s, in_usage);
            return castState<UsageSet>();
        }

        Ref<ThreadInfo> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ThreadInfo) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<ThreadInfo>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ThreadInfo> result = ThreadInfo::create()
     *     .setName(...)
     *     .setUsage(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setType(Type in_opt_type)
    {
        JSON::ObjectBase::setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_opt_type));
    }

    void setTargetId(const String& in_opt_targetId)
    {
        JSON::ObjectBase::setString("targetId"_s, in_opt_targetId);
    }
};

class Event final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TimestampSet = 1 << 0,
        UsageSet = 1 << 1,
        AllFieldsSet = (TimestampSet | UsageSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Event*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Event;
    public:

        Builder<STATE | TimestampSet>& setTimestamp(double in_timestamp)
        {
            COMPILE_ASSERT(!(STATE & TimestampSet), property_timestamp_already_set);
            m_result->setDouble("timestamp"_s, in_timestamp);
            return castState<TimestampSet>();
        }

        Builder<STATE | UsageSet>& setUsage(double in_usage)
        {
            COMPILE_ASSERT(!(STATE & UsageSet), property_usage_already_set);
            m_result->setDouble("usage"_s, in_usage);
            return castState<UsageSet>();
        }

        Ref<Event> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Event) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Event>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Event> result = Event::create()
     *     .setTimestamp(...)
     *     .setUsage(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setThreads(Ref<JSON::ArrayOf<Protocol::CPUProfiler::ThreadInfo>>&& in_opt_threads)
    {
        JSON::ObjectBase::setArray("threads"_s, WTFMove(in_opt_threads));
    }
};

} // CPUProfiler
#endif // defined(ENABLE_RESOURCE_USAGE) && ENABLE_RESOURCE_USAGE

namespace CSS {

/* This object identifies a CSS style in a unique way. */
class CSSStyleId final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        OrdinalSet = 1 << 1,
        AllFieldsSet = (StyleSheetIdSet | OrdinalSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSStyleId*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSStyleId;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(const String& in_styleSheetId)
        {
            COMPILE_ASSERT(!(STATE & StyleSheetIdSet), property_styleSheetId_already_set);
            m_result->setString("styleSheetId"_s, in_styleSheetId);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | OrdinalSet>& setOrdinal(int in_ordinal)
        {
            COMPILE_ASSERT(!(STATE & OrdinalSet), property_ordinal_already_set);
            m_result->setInteger("ordinal"_s, in_ordinal);
            return castState<OrdinalSet>();
        }

        Ref<CSSStyleId> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSStyleId) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CSSStyleId>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSStyleId> result = CSSStyleId::create()
     *     .setStyleSheetId(...)
     *     .setOrdinal(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Stylesheet type: "user" for user stylesheets, "user-agent" for user-agent stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via inspector" rules), "regular" for regular stylesheets. */
enum class StyleSheetOrigin {
    User = 16,
    UserAgent = 17,
    Author = 18,
    Inspector = 19,
}; // enum class StyleSheetOrigin

/* This object identifies a CSS rule in a unique way. */
class CSSRuleId final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        OrdinalSet = 1 << 1,
        AllFieldsSet = (StyleSheetIdSet | OrdinalSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSRuleId*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSRuleId;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(const String& in_styleSheetId)
        {
            COMPILE_ASSERT(!(STATE & StyleSheetIdSet), property_styleSheetId_already_set);
            m_result->setString("styleSheetId"_s, in_styleSheetId);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | OrdinalSet>& setOrdinal(int in_ordinal)
        {
            COMPILE_ASSERT(!(STATE & OrdinalSet), property_ordinal_already_set);
            m_result->setInteger("ordinal"_s, in_ordinal);
            return castState<OrdinalSet>();
        }

        Ref<CSSRuleId> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSRuleId) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CSSRuleId>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSRuleId> result = CSSRuleId::create()
     *     .setStyleSheetId(...)
     *     .setOrdinal(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Pseudo-style identifier (see <code>enum PseudoId</code> in <code>RenderStyleConstants.h</code>). */
enum class PseudoId {
    FirstLine = 20,
    FirstLetter = 21,
    Highlight = 22,
    Marker = 23,
    Before = 24,
    After = 25,
    Selection = 26,
    Scrollbar = 27,
    ScrollbarThumb = 28,
    ScrollbarButton = 29,
    ScrollbarTrack = 30,
    ScrollbarTrackPiece = 31,
    ScrollbarCorner = 32,
    Resizer = 33,
}; // enum class PseudoId

/* CSS rule collection for a single pseudo style. */
class PseudoIdMatches final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        PseudoIdSet = 1 << 0,
        MatchesSet = 1 << 1,
        AllFieldsSet = (PseudoIdSet | MatchesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*PseudoIdMatches*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class PseudoIdMatches;
    public:

        Builder<STATE | PseudoIdSet>& setPseudoId(Protocol::CSS::PseudoId in_pseudoId)
        {
            COMPILE_ASSERT(!(STATE & PseudoIdSet), property_pseudoId_already_set);
            m_result->setString("pseudoId"_s, Protocol::Helpers::getEnumConstantValue(in_pseudoId));
            return castState<PseudoIdSet>();
        }

        Builder<STATE | MatchesSet>& setMatches(Ref<JSON::ArrayOf<Protocol::CSS::RuleMatch>>&& in_matches)
        {
            COMPILE_ASSERT(!(STATE & MatchesSet), property_matches_already_set);
            m_result->setArray("matches"_s, WTFMove(in_matches));
            return castState<MatchesSet>();
        }

        Ref<PseudoIdMatches> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(PseudoIdMatches) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<PseudoIdMatches>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<PseudoIdMatches> result = PseudoIdMatches::create()
     *     .setPseudoId(...)
     *     .setMatches(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* CSS rule collection for a single pseudo style. */
class InheritedStyleEntry final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        MatchedCSSRulesSet = 1 << 0,
        AllFieldsSet = (MatchedCSSRulesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*InheritedStyleEntry*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class InheritedStyleEntry;
    public:

        Builder<STATE | MatchedCSSRulesSet>& setMatchedCSSRules(Ref<JSON::ArrayOf<Protocol::CSS::RuleMatch>>&& in_matchedCSSRules)
        {
            COMPILE_ASSERT(!(STATE & MatchedCSSRulesSet), property_matchedCSSRules_already_set);
            m_result->setArray("matchedCSSRules"_s, WTFMove(in_matchedCSSRules));
            return castState<MatchedCSSRulesSet>();
        }

        Ref<InheritedStyleEntry> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(InheritedStyleEntry) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<InheritedStyleEntry>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<InheritedStyleEntry> result = InheritedStyleEntry::create()
     *     .setMatchedCSSRules(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setInlineStyle(Ref<Protocol::CSS::CSSStyle>&& in_opt_inlineStyle)
    {
        JSON::ObjectBase::setObject("inlineStyle"_s, WTFMove(in_opt_inlineStyle));
    }
};

/* Match data for a CSS rule. */
class RuleMatch final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        RuleSet = 1 << 0,
        MatchingSelectorsSet = 1 << 1,
        AllFieldsSet = (RuleSet | MatchingSelectorsSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*RuleMatch*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class RuleMatch;
    public:

        Builder<STATE | RuleSet>& setRule(Ref<Protocol::CSS::CSSRule>&& in_rule)
        {
            COMPILE_ASSERT(!(STATE & RuleSet), property_rule_already_set);
            m_result->setObject("rule"_s, WTFMove(in_rule));
            return castState<RuleSet>();
        }

        Builder<STATE | MatchingSelectorsSet>& setMatchingSelectors(Ref<JSON::ArrayOf<int>>&& in_matchingSelectors)
        {
            COMPILE_ASSERT(!(STATE & MatchingSelectorsSet), property_matchingSelectors_already_set);
            m_result->setArray("matchingSelectors"_s, WTFMove(in_matchingSelectors));
            return castState<MatchingSelectorsSet>();
        }

        Ref<RuleMatch> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(RuleMatch) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<RuleMatch>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<RuleMatch> result = RuleMatch::create()
     *     .setRule(...)
     *     .setMatchingSelectors(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* CSS selector. */
class CSSSelector final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TextSet = 1 << 0,
        AllFieldsSet = (TextSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSSelector*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSSelector;
    public:

        Builder<STATE | TextSet>& setText(const String& in_text)
        {
            COMPILE_ASSERT(!(STATE & TextSet), property_text_already_set);
            m_result->setString("text"_s, in_text);
            return castState<TextSet>();
        }

        Ref<CSSSelector> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSSelector) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CSSSelector>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSSelector> result = CSSSelector::create()
     *     .setText(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setSpecificity(Ref<JSON::ArrayOf<int>>&& in_opt_specificity)
    {
        JSON::ObjectBase::setArray("specificity"_s, WTFMove(in_opt_specificity));
    }

    void setDynamic(bool in_opt_dynamic)
    {
        JSON::ObjectBase::setBoolean("dynamic"_s, in_opt_dynamic);
    }
};

/* Selector list data. */
class SelectorList final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SelectorsSet = 1 << 0,
        TextSet = 1 << 1,
        AllFieldsSet = (SelectorsSet | TextSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*SelectorList*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class SelectorList;
    public:

        Builder<STATE | SelectorsSet>& setSelectors(Ref<JSON::ArrayOf<Protocol::CSS::CSSSelector>>&& in_selectors)
        {
            COMPILE_ASSERT(!(STATE & SelectorsSet), property_selectors_already_set);
            m_result->setArray("selectors"_s, WTFMove(in_selectors));
            return castState<SelectorsSet>();
        }

        Builder<STATE | TextSet>& setText(const String& in_text)
        {
            COMPILE_ASSERT(!(STATE & TextSet), property_text_already_set);
            m_result->setString("text"_s, in_text);
            return castState<TextSet>();
        }

        Ref<SelectorList> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(SelectorList) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<SelectorList>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<SelectorList> result = SelectorList::create()
     *     .setSelectors(...)
     *     .setText(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setRange(Ref<Protocol::CSS::SourceRange>&& in_opt_range)
    {
        JSON::ObjectBase::setObject("range"_s, WTFMove(in_opt_range));
    }
};

/* CSS style information for a DOM style attribute. */
class CSSStyleAttribute final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        StyleSet = 1 << 1,
        AllFieldsSet = (NameSet | StyleSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSStyleAttribute*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSStyleAttribute;
    public:

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Builder<STATE | StyleSet>& setStyle(Ref<Protocol::CSS::CSSStyle>&& in_style)
        {
            COMPILE_ASSERT(!(STATE & StyleSet), property_style_already_set);
            m_result->setObject("style"_s, WTFMove(in_style));
            return castState<StyleSet>();
        }

        Ref<CSSStyleAttribute> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSStyleAttribute) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CSSStyleAttribute>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSStyleAttribute> result = CSSStyleAttribute::create()
     *     .setName(...)
     *     .setStyle(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* CSS stylesheet meta-information. */
class CSSStyleSheetHeader final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        FrameIdSet = 1 << 1,
        SourceURLSet = 1 << 2,
        OriginSet = 1 << 3,
        TitleSet = 1 << 4,
        DisabledSet = 1 << 5,
        IsInlineSet = 1 << 6,
        StartLineSet = 1 << 7,
        StartColumnSet = 1 << 8,
        AllFieldsSet = (StyleSheetIdSet | FrameIdSet | SourceURLSet | OriginSet | TitleSet | DisabledSet | IsInlineSet | StartLineSet | StartColumnSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSStyleSheetHeader*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSStyleSheetHeader;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(const String& in_styleSheetId)
        {
            COMPILE_ASSERT(!(STATE & StyleSheetIdSet), property_styleSheetId_already_set);
            m_result->setString("styleSheetId"_s, in_styleSheetId);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | FrameIdSet>& setFrameId(const String& in_frameId)
        {
            COMPILE_ASSERT(!(STATE & FrameIdSet), property_frameId_already_set);
            m_result->setString("frameId"_s, in_frameId);
            return castState<FrameIdSet>();
        }

        Builder<STATE | SourceURLSet>& setSourceURL(const String& in_sourceURL)
        {
            COMPILE_ASSERT(!(STATE & SourceURLSet), property_sourceURL_already_set);
            m_result->setString("sourceURL"_s, in_sourceURL);
            return castState<SourceURLSet>();
        }

        Builder<STATE | OriginSet>& setOrigin(Protocol::CSS::StyleSheetOrigin in_origin)
        {
            COMPILE_ASSERT(!(STATE & OriginSet), property_origin_already_set);
            m_result->setString("origin"_s, Protocol::Helpers::getEnumConstantValue(in_origin));
            return castState<OriginSet>();
        }

        Builder<STATE | TitleSet>& setTitle(const String& in_title)
        {
            COMPILE_ASSERT(!(STATE & TitleSet), property_title_already_set);
            m_result->setString("title"_s, in_title);
            return castState<TitleSet>();
        }

        Builder<STATE | DisabledSet>& setDisabled(bool in_disabled)
        {
            COMPILE_ASSERT(!(STATE & DisabledSet), property_disabled_already_set);
            m_result->setBoolean("disabled"_s, in_disabled);
            return castState<DisabledSet>();
        }

        Builder<STATE | IsInlineSet>& setIsInline(bool in_isInline)
        {
            COMPILE_ASSERT(!(STATE & IsInlineSet), property_isInline_already_set);
            m_result->setBoolean("isInline"_s, in_isInline);
            return castState<IsInlineSet>();
        }

        Builder<STATE | StartLineSet>& setStartLine(double in_startLine)
        {
            COMPILE_ASSERT(!(STATE & StartLineSet), property_startLine_already_set);
            m_result->setDouble("startLine"_s, in_startLine);
            return castState<StartLineSet>();
        }

        Builder<STATE | StartColumnSet>& setStartColumn(double in_startColumn)
        {
            COMPILE_ASSERT(!(STATE & StartColumnSet), property_startColumn_already_set);
            m_result->setDouble("startColumn"_s, in_startColumn);
            return castState<StartColumnSet>();
        }

        Ref<CSSStyleSheetHeader> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSStyleSheetHeader) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CSSStyleSheetHeader>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSStyleSheetHeader> result = CSSStyleSheetHeader::create()
     *     .setStyleSheetId(...)
     *     .setFrameId(...)
     *     .setSourceURL(...)
     *     .setOrigin(...)
     *     .setTitle(...)
     *     .setDisabled(...)
     *     .setIsInline(...)
     *     .setStartLine(...)
     *     .setStartColumn(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* CSS stylesheet contents. */
class CSSStyleSheetBody final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        RulesSet = 1 << 1,
        AllFieldsSet = (StyleSheetIdSet | RulesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSStyleSheetBody*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSStyleSheetBody;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(const String& in_styleSheetId)
        {
            COMPILE_ASSERT(!(STATE & StyleSheetIdSet), property_styleSheetId_already_set);
            m_result->setString("styleSheetId"_s, in_styleSheetId);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | RulesSet>& setRules(Ref<JSON::ArrayOf<Protocol::CSS::CSSRule>>&& in_rules)
        {
            COMPILE_ASSERT(!(STATE & RulesSet), property_rules_already_set);
            m_result->setArray("rules"_s, WTFMove(in_rules));
            return castState<RulesSet>();
        }

        Ref<CSSStyleSheetBody> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSStyleSheetBody) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CSSStyleSheetBody>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSStyleSheetBody> result = CSSStyleSheetBody::create()
     *     .setStyleSheetId(...)
     *     .setRules(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setText(const String& in_opt_text)
    {
        JSON::ObjectBase::setString("text"_s, in_opt_text);
    }
};

/* CSS rule representation. */
class CSSRule final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SelectorListSet = 1 << 0,
        SourceLineSet = 1 << 1,
        OriginSet = 1 << 2,
        StyleSet = 1 << 3,
        AllFieldsSet = (SelectorListSet | SourceLineSet | OriginSet | StyleSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSRule*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSRule;
    public:

        Builder<STATE | SelectorListSet>& setSelectorList(Ref<Protocol::CSS::SelectorList>&& in_selectorList)
        {
            COMPILE_ASSERT(!(STATE & SelectorListSet), property_selectorList_already_set);
            m_result->setObject("selectorList"_s, WTFMove(in_selectorList));
            return castState<SelectorListSet>();
        }

        Builder<STATE | SourceLineSet>& setSourceLine(int in_sourceLine)
        {
            COMPILE_ASSERT(!(STATE & SourceLineSet), property_sourceLine_already_set);
            m_result->setInteger("sourceLine"_s, in_sourceLine);
            return castState<SourceLineSet>();
        }

        Builder<STATE | OriginSet>& setOrigin(Protocol::CSS::StyleSheetOrigin in_origin)
        {
            COMPILE_ASSERT(!(STATE & OriginSet), property_origin_already_set);
            m_result->setString("origin"_s, Protocol::Helpers::getEnumConstantValue(in_origin));
            return castState<OriginSet>();
        }

        Builder<STATE | StyleSet>& setStyle(Ref<Protocol::CSS::CSSStyle>&& in_style)
        {
            COMPILE_ASSERT(!(STATE & StyleSet), property_style_already_set);
            m_result->setObject("style"_s, WTFMove(in_style));
            return castState<StyleSet>();
        }

        Ref<CSSRule> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSRule) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CSSRule>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSRule> result = CSSRule::create()
     *     .setSelectorList(...)
     *     .setSourceLine(...)
     *     .setOrigin(...)
     *     .setStyle(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setRuleId(Ref<Protocol::CSS::CSSRuleId>&& in_opt_ruleId)
    {
        JSON::ObjectBase::setObject("ruleId"_s, WTFMove(in_opt_ruleId));
    }

    void setSourceURL(const String& in_opt_sourceURL)
    {
        JSON::ObjectBase::setString("sourceURL"_s, in_opt_sourceURL);
    }

    void setGroupings(Ref<JSON::ArrayOf<Protocol::CSS::Grouping>>&& in_opt_groupings)
    {
        JSON::ObjectBase::setArray("groupings"_s, WTFMove(in_opt_groupings));
    }
};

/* Text range within a resource. */
class SourceRange final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StartLineSet = 1 << 0,
        StartColumnSet = 1 << 1,
        EndLineSet = 1 << 2,
        EndColumnSet = 1 << 3,
        AllFieldsSet = (StartLineSet | StartColumnSet | EndLineSet | EndColumnSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*SourceRange*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class SourceRange;
    public:

        Builder<STATE | StartLineSet>& setStartLine(int in_startLine)
        {
            COMPILE_ASSERT(!(STATE & StartLineSet), property_startLine_already_set);
            m_result->setInteger("startLine"_s, in_startLine);
            return castState<StartLineSet>();
        }

        Builder<STATE | StartColumnSet>& setStartColumn(int in_startColumn)
        {
            COMPILE_ASSERT(!(STATE & StartColumnSet), property_startColumn_already_set);
            m_result->setInteger("startColumn"_s, in_startColumn);
            return castState<StartColumnSet>();
        }

        Builder<STATE | EndLineSet>& setEndLine(int in_endLine)
        {
            COMPILE_ASSERT(!(STATE & EndLineSet), property_endLine_already_set);
            m_result->setInteger("endLine"_s, in_endLine);
            return castState<EndLineSet>();
        }

        Builder<STATE | EndColumnSet>& setEndColumn(int in_endColumn)
        {
            COMPILE_ASSERT(!(STATE & EndColumnSet), property_endColumn_already_set);
            m_result->setInteger("endColumn"_s, in_endColumn);
            return castState<EndColumnSet>();
        }

        Ref<SourceRange> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(SourceRange) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<SourceRange>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<SourceRange> result = SourceRange::create()
     *     .setStartLine(...)
     *     .setStartColumn(...)
     *     .setEndLine(...)
     *     .setEndColumn(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

class ShorthandEntry final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (NameSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ShorthandEntry*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ShorthandEntry;
    public:

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& in_value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString("value"_s, in_value);
            return castState<ValueSet>();
        }

        Ref<ShorthandEntry> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ShorthandEntry) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<ShorthandEntry>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ShorthandEntry> result = ShorthandEntry::create()
     *     .setName(...)
     *     .setValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

class CSSPropertyInfo final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        AllFieldsSet = (NameSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSPropertyInfo*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSPropertyInfo;
    public:

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Ref<CSSPropertyInfo> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSPropertyInfo) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CSSPropertyInfo>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSPropertyInfo> result = CSSPropertyInfo::create()
     *     .setName(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setAliases(Ref<JSON::ArrayOf<String>>&& in_opt_aliases)
    {
        JSON::ObjectBase::setArray("aliases"_s, WTFMove(in_opt_aliases));
    }

    void setLonghands(Ref<JSON::ArrayOf<String>>&& in_opt_longhands)
    {
        JSON::ObjectBase::setArray("longhands"_s, WTFMove(in_opt_longhands));
    }

    void setValues(Ref<JSON::ArrayOf<String>>&& in_opt_values)
    {
        JSON::ObjectBase::setArray("values"_s, WTFMove(in_opt_values));
    }

    void setInherited(bool in_opt_inherited)
    {
        JSON::ObjectBase::setBoolean("inherited"_s, in_opt_inherited);
    }
};

class CSSComputedStyleProperty final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (NameSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSComputedStyleProperty*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSComputedStyleProperty;
    public:

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& in_value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString("value"_s, in_value);
            return castState<ValueSet>();
        }

        Ref<CSSComputedStyleProperty> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSComputedStyleProperty) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CSSComputedStyleProperty>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSComputedStyleProperty> result = CSSComputedStyleProperty::create()
     *     .setName(...)
     *     .setValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* CSS style representation. */
class CSSStyle final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        CssPropertiesSet = 1 << 0,
        ShorthandEntriesSet = 1 << 1,
        AllFieldsSet = (CssPropertiesSet | ShorthandEntriesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSStyle*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSStyle;
    public:

        Builder<STATE | CssPropertiesSet>& setCssProperties(Ref<JSON::ArrayOf<Protocol::CSS::CSSProperty>>&& in_cssProperties)
        {
            COMPILE_ASSERT(!(STATE & CssPropertiesSet), property_cssProperties_already_set);
            m_result->setArray("cssProperties"_s, WTFMove(in_cssProperties));
            return castState<CssPropertiesSet>();
        }

        Builder<STATE | ShorthandEntriesSet>& setShorthandEntries(Ref<JSON::ArrayOf<Protocol::CSS::ShorthandEntry>>&& in_shorthandEntries)
        {
            COMPILE_ASSERT(!(STATE & ShorthandEntriesSet), property_shorthandEntries_already_set);
            m_result->setArray("shorthandEntries"_s, WTFMove(in_shorthandEntries));
            return castState<ShorthandEntriesSet>();
        }

        Ref<CSSStyle> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSStyle) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CSSStyle>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSStyle> result = CSSStyle::create()
     *     .setCssProperties(...)
     *     .setShorthandEntries(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setStyleId(Ref<Protocol::CSS::CSSStyleId>&& in_opt_styleId)
    {
        JSON::ObjectBase::setObject("styleId"_s, WTFMove(in_opt_styleId));
    }

    void setCssText(const String& in_opt_cssText)
    {
        JSON::ObjectBase::setString("cssText"_s, in_opt_cssText);
    }

    void setRange(Ref<Protocol::CSS::SourceRange>&& in_opt_range)
    {
        JSON::ObjectBase::setObject("range"_s, WTFMove(in_opt_range));
    }

    void setWidth(const String& in_opt_width)
    {
        JSON::ObjectBase::setString("width"_s, in_opt_width);
    }

    void setHeight(const String& in_opt_height)
    {
        JSON::ObjectBase::setString("height"_s, in_opt_height);
    }
};

/* The property status: "active" if the property is effective in the style, "inactive" if the property is overridden by a same-named property in this style later on, "disabled" if the property is disabled by the user, "style" (implied if absent) if the property is reported by the browser rather than by the CSS source parser. */
enum class CSSPropertyStatus {
    Active = 2,
    Inactive = 34,
    Disabled = 35,
    Style = 36,
}; // enum class CSSPropertyStatus

/* CSS style effective visual dimensions and source offsets. */
class CSSProperty final : public JSON::Object {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (NameSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSProperty*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSProperty;
    public:

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& in_value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString("value"_s, in_value);
            return castState<ValueSet>();
        }

        Ref<CSSProperty> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSProperty) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CSSProperty>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSProperty> result = CSSProperty::create()
     *     .setName(...)
     *     .setValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setPriority(const String& in_opt_priority)
    {
        JSON::ObjectBase::setString("priority"_s, in_opt_priority);
    }

    void setImplicit(bool in_opt_implicit)
    {
        JSON::ObjectBase::setBoolean("implicit"_s, in_opt_implicit);
    }

    void setText(const String& in_opt_text)
    {
        JSON::ObjectBase::setString("text"_s, in_opt_text);
    }

    void setParsedOk(bool in_opt_parsedOk)
    {
        JSON::ObjectBase::setBoolean("parsedOk"_s, in_opt_parsedOk);
    }

    void setStatus(Protocol::CSS::CSSPropertyStatus in_opt_status)
    {
        JSON::ObjectBase::setString("status"_s, Protocol::Helpers::getEnumConstantValue(in_opt_status));
    }

    void setRange(Ref<Protocol::CSS::SourceRange>&& in_opt_range)
    {
        JSON::ObjectBase::setObject("range"_s, WTFMove(in_opt_range));
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* priorityKey;
    JS_EXPORT_PRIVATE static const char* parsedOkKey;
    JS_EXPORT_PRIVATE static const char* statusKey;
};

/* CSS @media (as well as other users of media queries, like @import, <style>, <link>, etc.) and @supports descriptor. */
class Grouping final : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating Grouping.
    enum class Type {
        MediaRule = 37,
        MediaImportRule = 38,
        MediaLinkNode = 39,
        MediaStyleNode = 40,
        SupportsRule = 41,
    }; // enum class Type

    enum {
        NoFieldsSet = 0,
        TextSet = 1 << 0,
        TypeSet = 1 << 1,
        AllFieldsSet = (TextSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Grouping*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Grouping;
    public:

        Builder<STATE | TextSet>& setText(const String& in_text)
        {
            COMPILE_ASSERT(!(STATE & TextSet), property_text_already_set);
            m_result->setString("text"_s, in_text);
            return castState<TextSet>();
        }

        Builder<STATE | TypeSet>& setType(Type in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Ref<Grouping> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Grouping) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Grouping>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Grouping> result = Grouping::create()
     *     .setText(...)
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setSourceURL(const String& in_opt_sourceURL)
    {
        JSON::ObjectBase::setString("sourceURL"_s, in_opt_sourceURL);
    }
};

} // CSS

namespace Canvas {

/* The type of rendering context backing the canvas element. */
enum class ContextType {
    Canvas2D = 42,
    BitmapRenderer = 43,
    WebGL = 44,
    WebGL2 = 45,
    WebGPU = 46,
}; // enum class ContextType

#if (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
enum class ProgramType {
    Compute = 47,
    Render = 48,
}; // enum class ProgramType
#endif // (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)

#if (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
enum class ShaderType {
    Compute = 47,
    Fragment = 49,
    Vertex = 50,
}; // enum class ShaderType
#endif // (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)

/* Drawing surface attributes. */
class ContextAttributes final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ContextAttributes*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ContextAttributes;
    public:

        Ref<ContextAttributes> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ContextAttributes) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<ContextAttributes>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ContextAttributes> result = ContextAttributes::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setAlpha(bool in_opt_alpha)
    {
        JSON::ObjectBase::setBoolean("alpha"_s, in_opt_alpha);
    }

    void setDepth(bool in_opt_depth)
    {
        JSON::ObjectBase::setBoolean("depth"_s, in_opt_depth);
    }

    void setStencil(bool in_opt_stencil)
    {
        JSON::ObjectBase::setBoolean("stencil"_s, in_opt_stencil);
    }

    void setAntialias(bool in_opt_antialias)
    {
        JSON::ObjectBase::setBoolean("antialias"_s, in_opt_antialias);
    }

    void setPremultipliedAlpha(bool in_opt_premultipliedAlpha)
    {
        JSON::ObjectBase::setBoolean("premultipliedAlpha"_s, in_opt_premultipliedAlpha);
    }

    void setPreserveDrawingBuffer(bool in_opt_preserveDrawingBuffer)
    {
        JSON::ObjectBase::setBoolean("preserveDrawingBuffer"_s, in_opt_preserveDrawingBuffer);
    }

    void setFailIfMajorPerformanceCaveat(bool in_opt_failIfMajorPerformanceCaveat)
    {
        JSON::ObjectBase::setBoolean("failIfMajorPerformanceCaveat"_s, in_opt_failIfMajorPerformanceCaveat);
    }

    void setPowerPreference(const String& in_opt_powerPreference)
    {
        JSON::ObjectBase::setString("powerPreference"_s, in_opt_powerPreference);
    }
};

/* Information about a canvas for which a rendering context has been created. */
class Canvas final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        CanvasIdSet = 1 << 0,
        ContextTypeSet = 1 << 1,
        AllFieldsSet = (CanvasIdSet | ContextTypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Canvas*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Canvas;
    public:

        Builder<STATE | CanvasIdSet>& setCanvasId(const String& in_canvasId)
        {
            COMPILE_ASSERT(!(STATE & CanvasIdSet), property_canvasId_already_set);
            m_result->setString("canvasId"_s, in_canvasId);
            return castState<CanvasIdSet>();
        }

        Builder<STATE | ContextTypeSet>& setContextType(Protocol::Canvas::ContextType in_contextType)
        {
            COMPILE_ASSERT(!(STATE & ContextTypeSet), property_contextType_already_set);
            m_result->setString("contextType"_s, Protocol::Helpers::getEnumConstantValue(in_contextType));
            return castState<ContextTypeSet>();
        }

        Ref<Canvas> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Canvas) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Canvas>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Canvas> result = Canvas::create()
     *     .setCanvasId(...)
     *     .setContextType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setNodeId(int in_opt_nodeId)
    {
        JSON::ObjectBase::setInteger("nodeId"_s, in_opt_nodeId);
    }

    void setCssCanvasName(const String& in_opt_cssCanvasName)
    {
        JSON::ObjectBase::setString("cssCanvasName"_s, in_opt_cssCanvasName);
    }

    void setContextAttributes(Ref<Protocol::Canvas::ContextAttributes>&& in_opt_contextAttributes)
    {
        JSON::ObjectBase::setObject("contextAttributes"_s, WTFMove(in_opt_contextAttributes));
    }

    void setMemoryCost(double in_opt_memoryCost)
    {
        JSON::ObjectBase::setDouble("memoryCost"_s, in_opt_memoryCost);
    }

    void setBacktrace(Ref<JSON::ArrayOf<Protocol::Console::CallFrame>>&& in_opt_backtrace)
    {
        JSON::ObjectBase::setArray("backtrace"_s, WTFMove(in_opt_backtrace));
    }
};

#if (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
/* Information about a WebGL/WebGL2 shader program or WebGPU shader pipeline. */
class ShaderProgram final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ProgramIdSet = 1 << 0,
        ProgramTypeSet = 1 << 1,
        CanvasIdSet = 1 << 2,
        AllFieldsSet = (ProgramIdSet | ProgramTypeSet | CanvasIdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ShaderProgram*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ShaderProgram;
    public:

        Builder<STATE | ProgramIdSet>& setProgramId(const String& in_programId)
        {
            COMPILE_ASSERT(!(STATE & ProgramIdSet), property_programId_already_set);
            m_result->setString("programId"_s, in_programId);
            return castState<ProgramIdSet>();
        }

        Builder<STATE | ProgramTypeSet>& setProgramType(Protocol::Canvas::ProgramType in_programType)
        {
            COMPILE_ASSERT(!(STATE & ProgramTypeSet), property_programType_already_set);
            m_result->setString("programType"_s, Protocol::Helpers::getEnumConstantValue(in_programType));
            return castState<ProgramTypeSet>();
        }

        Builder<STATE | CanvasIdSet>& setCanvasId(const String& in_canvasId)
        {
            COMPILE_ASSERT(!(STATE & CanvasIdSet), property_canvasId_already_set);
            m_result->setString("canvasId"_s, in_canvasId);
            return castState<CanvasIdSet>();
        }

        Ref<ShaderProgram> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ShaderProgram) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<ShaderProgram>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ShaderProgram> result = ShaderProgram::create()
     *     .setProgramId(...)
     *     .setProgramType(...)
     *     .setCanvasId(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setSharesVertexFragmentShader(bool in_opt_sharesVertexFragmentShader)
    {
        JSON::ObjectBase::setBoolean("sharesVertexFragmentShader"_s, in_opt_sharesVertexFragmentShader);
    }
};
#endif // (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)

} // Canvas

namespace Console {

/* Channels for different types of log messages. */
enum class ChannelSource {
    XML = 51,
    JavaScript = 52,
    Network = 53,
    ConsoleAPI = 54,
    Storage = 55,
    Appcache = 56,
    Rendering = 57,
    CSS = 58,
    Security = 59,
    ContentBlocker = 60,
    Media = 61,
    MediaSource = 62,
    WebRTC = 63,
    ITPDebug = 64,
    AdClickAttribution = 65,
    Other = 66,
}; // enum class ChannelSource

/* Level of logging. */
enum class ChannelLevel {
    Off = 67,
    Basic = 68,
    Verbose = 69,
}; // enum class ChannelLevel

/* Logging channel. */
class Channel final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SourceSet = 1 << 0,
        LevelSet = 1 << 1,
        AllFieldsSet = (SourceSet | LevelSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Channel*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Channel;
    public:

        Builder<STATE | SourceSet>& setSource(Protocol::Console::ChannelSource in_source)
        {
            COMPILE_ASSERT(!(STATE & SourceSet), property_source_already_set);
            m_result->setString("source"_s, Protocol::Helpers::getEnumConstantValue(in_source));
            return castState<SourceSet>();
        }

        Builder<STATE | LevelSet>& setLevel(Protocol::Console::ChannelLevel in_level)
        {
            COMPILE_ASSERT(!(STATE & LevelSet), property_level_already_set);
            m_result->setString("level"_s, Protocol::Helpers::getEnumConstantValue(in_level));
            return castState<LevelSet>();
        }

        Ref<Channel> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Channel) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Channel>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Channel> result = Channel::create()
     *     .setSource(...)
     *     .setLevel(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Console message. */
class ConsoleMessage final : public JSON::ObjectBase {
public:
    // Named after property name 'level' while generating ConsoleMessage.
    enum class Level {
        Log = 70,
        Info = 71,
        Warning = 72,
        Error = 73,
        Debug = 74,
    }; // enum class Level

    // Named after property name 'type' while generating ConsoleMessage.
    enum class Type {
        Log = 70,
        Dir = 75,
        DirXML = 76,
        Table = 77,
        Trace = 78,
        Clear = 79,
        StartGroup = 80,
        StartGroupCollapsed = 81,
        EndGroup = 82,
        Assert = 83,
        Timing = 84,
        Profile = 85,
        ProfileEnd = 86,
        Image = 87,
    }; // enum class Type

    enum {
        NoFieldsSet = 0,
        SourceSet = 1 << 0,
        LevelSet = 1 << 1,
        TextSet = 1 << 2,
        AllFieldsSet = (SourceSet | LevelSet | TextSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ConsoleMessage*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ConsoleMessage;
    public:

        Builder<STATE | SourceSet>& setSource(Protocol::Console::ChannelSource in_source)
        {
            COMPILE_ASSERT(!(STATE & SourceSet), property_source_already_set);
            m_result->setString("source"_s, Protocol::Helpers::getEnumConstantValue(in_source));
            return castState<SourceSet>();
        }

        Builder<STATE | LevelSet>& setLevel(Level in_level)
        {
            COMPILE_ASSERT(!(STATE & LevelSet), property_level_already_set);
            m_result->setString("level"_s, Protocol::Helpers::getEnumConstantValue(in_level));
            return castState<LevelSet>();
        }

        Builder<STATE | TextSet>& setText(const String& in_text)
        {
            COMPILE_ASSERT(!(STATE & TextSet), property_text_already_set);
            m_result->setString("text"_s, in_text);
            return castState<TextSet>();
        }

        Ref<ConsoleMessage> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ConsoleMessage) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<ConsoleMessage>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ConsoleMessage> result = ConsoleMessage::create()
     *     .setSource(...)
     *     .setLevel(...)
     *     .setText(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setType(Type in_opt_type)
    {
        JSON::ObjectBase::setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_opt_type));
    }

    void setUrl(const String& in_opt_url)
    {
        JSON::ObjectBase::setString("url"_s, in_opt_url);
    }

    void setLine(int in_opt_line)
    {
        JSON::ObjectBase::setInteger("line"_s, in_opt_line);
    }

    void setColumn(int in_opt_column)
    {
        JSON::ObjectBase::setInteger("column"_s, in_opt_column);
    }

    void setRepeatCount(int in_opt_repeatCount)
    {
        JSON::ObjectBase::setInteger("repeatCount"_s, in_opt_repeatCount);
    }

    void setParameters(Ref<JSON::ArrayOf<Protocol::Runtime::RemoteObject>>&& in_opt_parameters)
    {
        JSON::ObjectBase::setArray("parameters"_s, WTFMove(in_opt_parameters));
    }

    void setStackTrace(Ref<JSON::ArrayOf<Protocol::Console::CallFrame>>&& in_opt_stackTrace)
    {
        JSON::ObjectBase::setArray("stackTrace"_s, WTFMove(in_opt_stackTrace));
    }

    void setNetworkRequestId(const String& in_opt_networkRequestId)
    {
        JSON::ObjectBase::setString("networkRequestId"_s, in_opt_networkRequestId);
    }
};

/* Stack entry for console errors and assertions. */
class CallFrame final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        FunctionNameSet = 1 << 0,
        UrlSet = 1 << 1,
        ScriptIdSet = 1 << 2,
        LineNumberSet = 1 << 3,
        ColumnNumberSet = 1 << 4,
        AllFieldsSet = (FunctionNameSet | UrlSet | ScriptIdSet | LineNumberSet | ColumnNumberSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CallFrame*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CallFrame;
    public:

        Builder<STATE | FunctionNameSet>& setFunctionName(const String& in_functionName)
        {
            COMPILE_ASSERT(!(STATE & FunctionNameSet), property_functionName_already_set);
            m_result->setString("functionName"_s, in_functionName);
            return castState<FunctionNameSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& in_url)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url"_s, in_url);
            return castState<UrlSet>();
        }

        Builder<STATE | ScriptIdSet>& setScriptId(const String& in_scriptId)
        {
            COMPILE_ASSERT(!(STATE & ScriptIdSet), property_scriptId_already_set);
            m_result->setString("scriptId"_s, in_scriptId);
            return castState<ScriptIdSet>();
        }

        Builder<STATE | LineNumberSet>& setLineNumber(int in_lineNumber)
        {
            COMPILE_ASSERT(!(STATE & LineNumberSet), property_lineNumber_already_set);
            m_result->setInteger("lineNumber"_s, in_lineNumber);
            return castState<LineNumberSet>();
        }

        Builder<STATE | ColumnNumberSet>& setColumnNumber(int in_columnNumber)
        {
            COMPILE_ASSERT(!(STATE & ColumnNumberSet), property_columnNumber_already_set);
            m_result->setInteger("columnNumber"_s, in_columnNumber);
            return castState<ColumnNumberSet>();
        }

        Ref<CallFrame> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CallFrame) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CallFrame>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CallFrame> result = CallFrame::create()
     *     .setFunctionName(...)
     *     .setUrl(...)
     *     .setScriptId(...)
     *     .setLineNumber(...)
     *     .setColumnNumber(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Call frames for async function calls, console assertions, and error messages. */
class StackTrace final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        CallFramesSet = 1 << 0,
        AllFieldsSet = (CallFramesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*StackTrace*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class StackTrace;
    public:

        Builder<STATE | CallFramesSet>& setCallFrames(Ref<JSON::ArrayOf<Protocol::Console::CallFrame>>&& in_callFrames)
        {
            COMPILE_ASSERT(!(STATE & CallFramesSet), property_callFrames_already_set);
            m_result->setArray("callFrames"_s, WTFMove(in_callFrames));
            return castState<CallFramesSet>();
        }

        Ref<StackTrace> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(StackTrace) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<StackTrace>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<StackTrace> result = StackTrace::create()
     *     .setCallFrames(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setTopCallFrameIsBoundary(bool in_opt_topCallFrameIsBoundary)
    {
        JSON::ObjectBase::setBoolean("topCallFrameIsBoundary"_s, in_opt_topCallFrameIsBoundary);
    }

    void setTruncated(bool in_opt_truncated)
    {
        JSON::ObjectBase::setBoolean("truncated"_s, in_opt_truncated);
    }

    void setParentStackTrace(Ref<Protocol::Console::StackTrace>&& in_opt_parentStackTrace)
    {
        JSON::ObjectBase::setObject("parentStackTrace"_s, WTFMove(in_opt_parentStackTrace));
    }
};

} // Console

namespace DOM {

/* Pseudo element type. */
enum class PseudoType {
    Before = 24,
    After = 25,
}; // enum class PseudoType

/* Shadow root type. */
enum class ShadowRootType {
    UserAgent = 17,
    Open = 88,
    Closed = 89,
}; // enum class ShadowRootType

/* Custom element state. */
enum class CustomElementState {
    Builtin = 90,
    Custom = 91,
    Waiting = 92,
    Failed = 93,
}; // enum class CustomElementState

/* Token values of @aria-relevant attribute. */
enum class LiveRegionRelevant {
    Additions = 94,
    Removals = 95,
    Text = 96,
}; // enum class LiveRegionRelevant

/* DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type. */
class Node final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NodeIdSet = 1 << 0,
        NodeTypeSet = 1 << 1,
        NodeNameSet = 1 << 2,
        LocalNameSet = 1 << 3,
        NodeValueSet = 1 << 4,
        AllFieldsSet = (NodeIdSet | NodeTypeSet | NodeNameSet | LocalNameSet | NodeValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Node*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Node;
    public:

        Builder<STATE | NodeIdSet>& setNodeId(int in_nodeId)
        {
            COMPILE_ASSERT(!(STATE & NodeIdSet), property_nodeId_already_set);
            m_result->setInteger("nodeId"_s, in_nodeId);
            return castState<NodeIdSet>();
        }

        Builder<STATE | NodeTypeSet>& setNodeType(int in_nodeType)
        {
            COMPILE_ASSERT(!(STATE & NodeTypeSet), property_nodeType_already_set);
            m_result->setInteger("nodeType"_s, in_nodeType);
            return castState<NodeTypeSet>();
        }

        Builder<STATE | NodeNameSet>& setNodeName(const String& in_nodeName)
        {
            COMPILE_ASSERT(!(STATE & NodeNameSet), property_nodeName_already_set);
            m_result->setString("nodeName"_s, in_nodeName);
            return castState<NodeNameSet>();
        }

        Builder<STATE | LocalNameSet>& setLocalName(const String& in_localName)
        {
            COMPILE_ASSERT(!(STATE & LocalNameSet), property_localName_already_set);
            m_result->setString("localName"_s, in_localName);
            return castState<LocalNameSet>();
        }

        Builder<STATE | NodeValueSet>& setNodeValue(const String& in_nodeValue)
        {
            COMPILE_ASSERT(!(STATE & NodeValueSet), property_nodeValue_already_set);
            m_result->setString("nodeValue"_s, in_nodeValue);
            return castState<NodeValueSet>();
        }

        Ref<Node> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Node) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Node>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Node> result = Node::create()
     *     .setNodeId(...)
     *     .setNodeType(...)
     *     .setNodeName(...)
     *     .setLocalName(...)
     *     .setNodeValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setFrameId(const String& in_opt_frameId)
    {
        JSON::ObjectBase::setString("frameId"_s, in_opt_frameId);
    }

    void setChildNodeCount(int in_opt_childNodeCount)
    {
        JSON::ObjectBase::setInteger("childNodeCount"_s, in_opt_childNodeCount);
    }

    void setChildren(Ref<JSON::ArrayOf<Protocol::DOM::Node>>&& in_opt_children)
    {
        JSON::ObjectBase::setArray("children"_s, WTFMove(in_opt_children));
    }

    void setAttributes(Ref<JSON::ArrayOf<String>>&& in_opt_attributes)
    {
        JSON::ObjectBase::setArray("attributes"_s, WTFMove(in_opt_attributes));
    }

    void setDocumentURL(const String& in_opt_documentURL)
    {
        JSON::ObjectBase::setString("documentURL"_s, in_opt_documentURL);
    }

    void setBaseURL(const String& in_opt_baseURL)
    {
        JSON::ObjectBase::setString("baseURL"_s, in_opt_baseURL);
    }

    void setPublicId(const String& in_opt_publicId)
    {
        JSON::ObjectBase::setString("publicId"_s, in_opt_publicId);
    }

    void setSystemId(const String& in_opt_systemId)
    {
        JSON::ObjectBase::setString("systemId"_s, in_opt_systemId);
    }

    void setXmlVersion(const String& in_opt_xmlVersion)
    {
        JSON::ObjectBase::setString("xmlVersion"_s, in_opt_xmlVersion);
    }

    void setName(const String& in_opt_name)
    {
        JSON::ObjectBase::setString("name"_s, in_opt_name);
    }

    void setValue(const String& in_opt_value)
    {
        JSON::ObjectBase::setString("value"_s, in_opt_value);
    }

    void setPseudoType(Protocol::DOM::PseudoType in_opt_pseudoType)
    {
        JSON::ObjectBase::setString("pseudoType"_s, Protocol::Helpers::getEnumConstantValue(in_opt_pseudoType));
    }

    void setShadowRootType(Protocol::DOM::ShadowRootType in_opt_shadowRootType)
    {
        JSON::ObjectBase::setString("shadowRootType"_s, Protocol::Helpers::getEnumConstantValue(in_opt_shadowRootType));
    }

    void setCustomElementState(Protocol::DOM::CustomElementState in_opt_customElementState)
    {
        JSON::ObjectBase::setString("customElementState"_s, Protocol::Helpers::getEnumConstantValue(in_opt_customElementState));
    }

    void setContentDocument(Ref<Protocol::DOM::Node>&& in_opt_contentDocument)
    {
        JSON::ObjectBase::setObject("contentDocument"_s, WTFMove(in_opt_contentDocument));
    }

    void setShadowRoots(Ref<JSON::ArrayOf<Protocol::DOM::Node>>&& in_opt_shadowRoots)
    {
        JSON::ObjectBase::setArray("shadowRoots"_s, WTFMove(in_opt_shadowRoots));
    }

    void setTemplateContent(Ref<Protocol::DOM::Node>&& in_opt_templateContent)
    {
        JSON::ObjectBase::setObject("templateContent"_s, WTFMove(in_opt_templateContent));
    }

    void setPseudoElements(Ref<JSON::ArrayOf<Protocol::DOM::Node>>&& in_opt_pseudoElements)
    {
        JSON::ObjectBase::setArray("pseudoElements"_s, WTFMove(in_opt_pseudoElements));
    }

    void setContentSecurityPolicyHash(const String& in_opt_contentSecurityPolicyHash)
    {
        JSON::ObjectBase::setString("contentSecurityPolicyHash"_s, in_opt_contentSecurityPolicyHash);
    }
};

/* Relationship between data that is associated with a node and the node itself. */
class DataBinding final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        BindingSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (BindingSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*DataBinding*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class DataBinding;
    public:

        Builder<STATE | BindingSet>& setBinding(const String& in_binding)
        {
            COMPILE_ASSERT(!(STATE & BindingSet), property_binding_already_set);
            m_result->setString("binding"_s, in_binding);
            return castState<BindingSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& in_value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString("value"_s, in_value);
            return castState<ValueSet>();
        }

        Ref<DataBinding> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(DataBinding) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<DataBinding>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<DataBinding> result = DataBinding::create()
     *     .setBinding(...)
     *     .setValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setType(const String& in_opt_type)
    {
        JSON::ObjectBase::setString("type"_s, in_opt_type);
    }
};

/* A structure holding event listener properties. */
class EventListener final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        EventListenerIdSet = 1 << 0,
        TypeSet = 1 << 1,
        UseCaptureSet = 1 << 2,
        IsAttributeSet = 1 << 3,
        AllFieldsSet = (EventListenerIdSet | TypeSet | UseCaptureSet | IsAttributeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*EventListener*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class EventListener;
    public:

        Builder<STATE | EventListenerIdSet>& setEventListenerId(int in_eventListenerId)
        {
            COMPILE_ASSERT(!(STATE & EventListenerIdSet), property_eventListenerId_already_set);
            m_result->setInteger("eventListenerId"_s, in_eventListenerId);
            return castState<EventListenerIdSet>();
        }

        Builder<STATE | TypeSet>& setType(const String& in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, in_type);
            return castState<TypeSet>();
        }

        Builder<STATE | UseCaptureSet>& setUseCapture(bool in_useCapture)
        {
            COMPILE_ASSERT(!(STATE & UseCaptureSet), property_useCapture_already_set);
            m_result->setBoolean("useCapture"_s, in_useCapture);
            return castState<UseCaptureSet>();
        }

        Builder<STATE | IsAttributeSet>& setIsAttribute(bool in_isAttribute)
        {
            COMPILE_ASSERT(!(STATE & IsAttributeSet), property_isAttribute_already_set);
            m_result->setBoolean("isAttribute"_s, in_isAttribute);
            return castState<IsAttributeSet>();
        }

        Ref<EventListener> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(EventListener) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<EventListener>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<EventListener> result = EventListener::create()
     *     .setEventListenerId(...)
     *     .setType(...)
     *     .setUseCapture(...)
     *     .setIsAttribute(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setNodeId(int in_opt_nodeId)
    {
        JSON::ObjectBase::setInteger("nodeId"_s, in_opt_nodeId);
    }

    void setOnWindow(bool in_opt_onWindow)
    {
        JSON::ObjectBase::setBoolean("onWindow"_s, in_opt_onWindow);
    }

    void setLocation(Ref<Protocol::Debugger::Location>&& in_opt_location)
    {
        JSON::ObjectBase::setObject("location"_s, WTFMove(in_opt_location));
    }

    void setHandlerName(const String& in_opt_handlerName)
    {
        JSON::ObjectBase::setString("handlerName"_s, in_opt_handlerName);
    }

    void setPassive(bool in_opt_passive)
    {
        JSON::ObjectBase::setBoolean("passive"_s, in_opt_passive);
    }

    void setOnce(bool in_opt_once)
    {
        JSON::ObjectBase::setBoolean("once"_s, in_opt_once);
    }

    void setDisabled(bool in_opt_disabled)
    {
        JSON::ObjectBase::setBoolean("disabled"_s, in_opt_disabled);
    }

    void setHasBreakpoint(bool in_opt_hasBreakpoint)
    {
        JSON::ObjectBase::setBoolean("hasBreakpoint"_s, in_opt_hasBreakpoint);
    }
};

/* A structure holding accessibility properties. */
class AccessibilityProperties final : public JSON::ObjectBase {
public:
    // Named after property name 'checked' while generating AccessibilityProperties.
    enum class Checked {
        True = 97,
        False = 98,
        Mixed = 99,
    }; // enum class Checked

    // Named after property name 'current' while generating AccessibilityProperties.
    enum class Current {
        True = 97,
        False = 98,
        Page = 100,
        Step = 101,
        Location = 102,
        Date = 103,
        Time = 104,
    }; // enum class Current

    // Named after property name 'invalid' while generating AccessibilityProperties.
    enum class Invalid {
        True = 97,
        False = 98,
        Grammar = 105,
        Spelling = 106,
    }; // enum class Invalid

    // Named after property name 'liveRegionStatus' while generating AccessibilityProperties.
    enum class LiveRegionStatus {
        Assertive = 107,
        Polite = 108,
        Off = 67,
    }; // enum class LiveRegionStatus

    enum {
        NoFieldsSet = 0,
        ExistsSet = 1 << 0,
        LabelSet = 1 << 1,
        NodeIdSet = 1 << 2,
        RoleSet = 1 << 3,
        AllFieldsSet = (ExistsSet | LabelSet | NodeIdSet | RoleSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*AccessibilityProperties*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class AccessibilityProperties;
    public:

        Builder<STATE | ExistsSet>& setExists(bool in_exists)
        {
            COMPILE_ASSERT(!(STATE & ExistsSet), property_exists_already_set);
            m_result->setBoolean("exists"_s, in_exists);
            return castState<ExistsSet>();
        }

        Builder<STATE | LabelSet>& setLabel(const String& in_label)
        {
            COMPILE_ASSERT(!(STATE & LabelSet), property_label_already_set);
            m_result->setString("label"_s, in_label);
            return castState<LabelSet>();
        }

        Builder<STATE | NodeIdSet>& setNodeId(int in_nodeId)
        {
            COMPILE_ASSERT(!(STATE & NodeIdSet), property_nodeId_already_set);
            m_result->setInteger("nodeId"_s, in_nodeId);
            return castState<NodeIdSet>();
        }

        Builder<STATE | RoleSet>& setRole(const String& in_role)
        {
            COMPILE_ASSERT(!(STATE & RoleSet), property_role_already_set);
            m_result->setString("role"_s, in_role);
            return castState<RoleSet>();
        }

        Ref<AccessibilityProperties> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(AccessibilityProperties) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<AccessibilityProperties>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<AccessibilityProperties> result = AccessibilityProperties::create()
     *     .setExists(...)
     *     .setLabel(...)
     *     .setNodeId(...)
     *     .setRole(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setActiveDescendantNodeId(int in_opt_activeDescendantNodeId)
    {
        JSON::ObjectBase::setInteger("activeDescendantNodeId"_s, in_opt_activeDescendantNodeId);
    }

    void setBusy(bool in_opt_busy)
    {
        JSON::ObjectBase::setBoolean("busy"_s, in_opt_busy);
    }

    void setChecked(Checked in_opt_checked)
    {
        JSON::ObjectBase::setString("checked"_s, Protocol::Helpers::getEnumConstantValue(in_opt_checked));
    }

    void setChildNodeIds(Ref<JSON::ArrayOf<int>>&& in_opt_childNodeIds)
    {
        JSON::ObjectBase::setArray("childNodeIds"_s, WTFMove(in_opt_childNodeIds));
    }

    void setControlledNodeIds(Ref<JSON::ArrayOf<int>>&& in_opt_controlledNodeIds)
    {
        JSON::ObjectBase::setArray("controlledNodeIds"_s, WTFMove(in_opt_controlledNodeIds));
    }

    void setCurrent(Current in_opt_current)
    {
        JSON::ObjectBase::setString("current"_s, Protocol::Helpers::getEnumConstantValue(in_opt_current));
    }

    void setDisabled(bool in_opt_disabled)
    {
        JSON::ObjectBase::setBoolean("disabled"_s, in_opt_disabled);
    }

    void setHeadingLevel(double in_opt_headingLevel)
    {
        JSON::ObjectBase::setDouble("headingLevel"_s, in_opt_headingLevel);
    }

    void setHierarchyLevel(double in_opt_hierarchyLevel)
    {
        JSON::ObjectBase::setDouble("hierarchyLevel"_s, in_opt_hierarchyLevel);
    }

    void setIsPopUpButton(bool in_opt_isPopUpButton)
    {
        JSON::ObjectBase::setBoolean("isPopUpButton"_s, in_opt_isPopUpButton);
    }

    void setExpanded(bool in_opt_expanded)
    {
        JSON::ObjectBase::setBoolean("expanded"_s, in_opt_expanded);
    }

    void setFlowedNodeIds(Ref<JSON::ArrayOf<int>>&& in_opt_flowedNodeIds)
    {
        JSON::ObjectBase::setArray("flowedNodeIds"_s, WTFMove(in_opt_flowedNodeIds));
    }

    void setFocused(bool in_opt_focused)
    {
        JSON::ObjectBase::setBoolean("focused"_s, in_opt_focused);
    }

    void setIgnored(bool in_opt_ignored)
    {
        JSON::ObjectBase::setBoolean("ignored"_s, in_opt_ignored);
    }

    void setIgnoredByDefault(bool in_opt_ignoredByDefault)
    {
        JSON::ObjectBase::setBoolean("ignoredByDefault"_s, in_opt_ignoredByDefault);
    }

    void setInvalid(Invalid in_opt_invalid)
    {
        JSON::ObjectBase::setString("invalid"_s, Protocol::Helpers::getEnumConstantValue(in_opt_invalid));
    }

    void setHidden(bool in_opt_hidden)
    {
        JSON::ObjectBase::setBoolean("hidden"_s, in_opt_hidden);
    }

    void setLiveRegionAtomic(bool in_opt_liveRegionAtomic)
    {
        JSON::ObjectBase::setBoolean("liveRegionAtomic"_s, in_opt_liveRegionAtomic);
    }

    void setLiveRegionRelevant(Ref<JSON::ArrayOf<String>>&& in_opt_liveRegionRelevant)
    {
        JSON::ObjectBase::setArray("liveRegionRelevant"_s, WTFMove(in_opt_liveRegionRelevant));
    }

    void setLiveRegionStatus(LiveRegionStatus in_opt_liveRegionStatus)
    {
        JSON::ObjectBase::setString("liveRegionStatus"_s, Protocol::Helpers::getEnumConstantValue(in_opt_liveRegionStatus));
    }

    void setMouseEventNodeId(int in_opt_mouseEventNodeId)
    {
        JSON::ObjectBase::setInteger("mouseEventNodeId"_s, in_opt_mouseEventNodeId);
    }

    void setOwnedNodeIds(Ref<JSON::ArrayOf<int>>&& in_opt_ownedNodeIds)
    {
        JSON::ObjectBase::setArray("ownedNodeIds"_s, WTFMove(in_opt_ownedNodeIds));
    }

    void setParentNodeId(int in_opt_parentNodeId)
    {
        JSON::ObjectBase::setInteger("parentNodeId"_s, in_opt_parentNodeId);
    }

    void setPressed(bool in_opt_pressed)
    {
        JSON::ObjectBase::setBoolean("pressed"_s, in_opt_pressed);
    }

    void setReadonly(bool in_opt_readonly)
    {
        JSON::ObjectBase::setBoolean("readonly"_s, in_opt_readonly);
    }

    void setRequired(bool in_opt_required)
    {
        JSON::ObjectBase::setBoolean("required"_s, in_opt_required);
    }

    void setSelected(bool in_opt_selected)
    {
        JSON::ObjectBase::setBoolean("selected"_s, in_opt_selected);
    }

    void setSelectedChildNodeIds(Ref<JSON::ArrayOf<int>>&& in_opt_selectedChildNodeIds)
    {
        JSON::ObjectBase::setArray("selectedChildNodeIds"_s, WTFMove(in_opt_selectedChildNodeIds));
    }
};

/* A structure holding an RGBA color. */
class RGBAColor final : public JSON::Object {
public:
    enum {
        NoFieldsSet = 0,
        RSet = 1 << 0,
        GSet = 1 << 1,
        BSet = 1 << 2,
        AllFieldsSet = (RSet | GSet | BSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*RGBAColor*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class RGBAColor;
    public:

        Builder<STATE | RSet>& setR(int in_r)
        {
            COMPILE_ASSERT(!(STATE & RSet), property_r_already_set);
            m_result->setInteger("r"_s, in_r);
            return castState<RSet>();
        }

        Builder<STATE | GSet>& setG(int in_g)
        {
            COMPILE_ASSERT(!(STATE & GSet), property_g_already_set);
            m_result->setInteger("g"_s, in_g);
            return castState<GSet>();
        }

        Builder<STATE | BSet>& setB(int in_b)
        {
            COMPILE_ASSERT(!(STATE & BSet), property_b_already_set);
            m_result->setInteger("b"_s, in_b);
            return castState<BSet>();
        }

        Ref<RGBAColor> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(RGBAColor) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<RGBAColor>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<RGBAColor> result = RGBAColor::create()
     *     .setR(...)
     *     .setG(...)
     *     .setB(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setA(double in_opt_a)
    {
        JSON::ObjectBase::setDouble("a"_s, in_opt_a);
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* rKey;
    JS_EXPORT_PRIVATE static const char* gKey;
    JS_EXPORT_PRIVATE static const char* bKey;
    JS_EXPORT_PRIVATE static const char* aKey;
};

/* Configuration data for the highlighting of page elements. */
class HighlightConfig final : public JSON::Object {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*HighlightConfig*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class HighlightConfig;
    public:

        Ref<HighlightConfig> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(HighlightConfig) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<HighlightConfig>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<HighlightConfig> result = HighlightConfig::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setShowInfo(bool in_opt_showInfo)
    {
        JSON::ObjectBase::setBoolean("showInfo"_s, in_opt_showInfo);
    }

    void setContentColor(Ref<Protocol::DOM::RGBAColor>&& in_opt_contentColor)
    {
        JSON::ObjectBase::setObject("contentColor"_s, WTFMove(in_opt_contentColor));
    }

    void setPaddingColor(Ref<Protocol::DOM::RGBAColor>&& in_opt_paddingColor)
    {
        JSON::ObjectBase::setObject("paddingColor"_s, WTFMove(in_opt_paddingColor));
    }

    void setBorderColor(Ref<Protocol::DOM::RGBAColor>&& in_opt_borderColor)
    {
        JSON::ObjectBase::setObject("borderColor"_s, WTFMove(in_opt_borderColor));
    }

    void setMarginColor(Ref<Protocol::DOM::RGBAColor>&& in_opt_marginColor)
    {
        JSON::ObjectBase::setObject("marginColor"_s, WTFMove(in_opt_marginColor));
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* showInfoKey;
    JS_EXPORT_PRIVATE static const char* contentColorKey;
    JS_EXPORT_PRIVATE static const char* paddingColorKey;
    JS_EXPORT_PRIVATE static const char* borderColorKey;
    JS_EXPORT_PRIVATE static const char* marginColorKey;
};

} // DOM

namespace DOMDebugger {

/* DOM breakpoint type. */
enum class DOMBreakpointType {
    SubtreeModified = 109,
    AttributeModified = 110,
    NodeRemoved = 111,
}; // enum class DOMBreakpointType

/* Event breakpoint type. */
enum class EventBreakpointType {
    AnimationFrame = 112,
    Interval = 113,
    Listener = 114,
    Timeout = 115,
}; // enum class EventBreakpointType

} // DOMDebugger

namespace DOMStorage {

/* DOM Storage identifier. */
class StorageId final : public JSON::Object {
public:
    enum {
        NoFieldsSet = 0,
        SecurityOriginSet = 1 << 0,
        IsLocalStorageSet = 1 << 1,
        AllFieldsSet = (SecurityOriginSet | IsLocalStorageSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*StorageId*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class StorageId;
    public:

        Builder<STATE | SecurityOriginSet>& setSecurityOrigin(const String& in_securityOrigin)
        {
            COMPILE_ASSERT(!(STATE & SecurityOriginSet), property_securityOrigin_already_set);
            m_result->setString("securityOrigin"_s, in_securityOrigin);
            return castState<SecurityOriginSet>();
        }

        Builder<STATE | IsLocalStorageSet>& setIsLocalStorage(bool in_isLocalStorage)
        {
            COMPILE_ASSERT(!(STATE & IsLocalStorageSet), property_isLocalStorage_already_set);
            m_result->setBoolean("isLocalStorage"_s, in_isLocalStorage);
            return castState<IsLocalStorageSet>();
        }

        Ref<StorageId> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(StorageId) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<StorageId>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<StorageId> result = StorageId::create()
     *     .setSecurityOrigin(...)
     *     .setIsLocalStorage(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* securityOriginKey;
    JS_EXPORT_PRIVATE static const char* isLocalStorageKey;
};

} // DOMStorage

namespace Database {

/* Database object. */
class Database final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        DomainSet = 1 << 1,
        NameSet = 1 << 2,
        VersionSet = 1 << 3,
        AllFieldsSet = (IdSet | DomainSet | NameSet | VersionSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Database*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Database;
    public:

        Builder<STATE | IdSet>& setId(const String& in_id)
        {
            COMPILE_ASSERT(!(STATE & IdSet), property_id_already_set);
            m_result->setString("id"_s, in_id);
            return castState<IdSet>();
        }

        Builder<STATE | DomainSet>& setDomain(const String& in_domain)
        {
            COMPILE_ASSERT(!(STATE & DomainSet), property_domain_already_set);
            m_result->setString("domain"_s, in_domain);
            return castState<DomainSet>();
        }

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Builder<STATE | VersionSet>& setVersion(const String& in_version)
        {
            COMPILE_ASSERT(!(STATE & VersionSet), property_version_already_set);
            m_result->setString("version"_s, in_version);
            return castState<VersionSet>();
        }

        Ref<Database> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Database) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Database>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Database> result = Database::create()
     *     .setId(...)
     *     .setDomain(...)
     *     .setName(...)
     *     .setVersion(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Database error. */
class Error final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        MessageSet = 1 << 0,
        CodeSet = 1 << 1,
        AllFieldsSet = (MessageSet | CodeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Error*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Error;
    public:

        Builder<STATE | MessageSet>& setMessage(const String& in_message)
        {
            COMPILE_ASSERT(!(STATE & MessageSet), property_message_already_set);
            m_result->setString("message"_s, in_message);
            return castState<MessageSet>();
        }

        Builder<STATE | CodeSet>& setCode(int in_code)
        {
            COMPILE_ASSERT(!(STATE & CodeSet), property_code_already_set);
            m_result->setInteger("code"_s, in_code);
            return castState<CodeSet>();
        }

        Ref<Error> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Error) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Error>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Error> result = Error::create()
     *     .setMessage(...)
     *     .setCode(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // Database

namespace Debugger {

/* Location in the source code. */
class Location final : public JSON::Object {
public:
    enum {
        NoFieldsSet = 0,
        ScriptIdSet = 1 << 0,
        LineNumberSet = 1 << 1,
        AllFieldsSet = (ScriptIdSet | LineNumberSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Location*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Location;
    public:

        Builder<STATE | ScriptIdSet>& setScriptId(const String& in_scriptId)
        {
            COMPILE_ASSERT(!(STATE & ScriptIdSet), property_scriptId_already_set);
            m_result->setString("scriptId"_s, in_scriptId);
            return castState<ScriptIdSet>();
        }

        Builder<STATE | LineNumberSet>& setLineNumber(int in_lineNumber)
        {
            COMPILE_ASSERT(!(STATE & LineNumberSet), property_lineNumber_already_set);
            m_result->setInteger("lineNumber"_s, in_lineNumber);
            return castState<LineNumberSet>();
        }

        Ref<Location> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Location) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Location>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Location> result = Location::create()
     *     .setScriptId(...)
     *     .setLineNumber(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setColumnNumber(int in_opt_columnNumber)
    {
        JSON::ObjectBase::setInteger("columnNumber"_s, in_opt_columnNumber);
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* scriptIdKey;
    JS_EXPORT_PRIVATE static const char* lineNumberKey;
    JS_EXPORT_PRIVATE static const char* columnNumberKey;
};

/* Action to perform when a breakpoint is triggered. */
class BreakpointAction final : public JSON::Object {
public:
    // Named after property name 'type' while generating BreakpointAction.
    enum class Type {
        Log = 70,
        Evaluate = 116,
        Sound = 117,
        Probe = 118,
    }; // enum class Type

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*BreakpointAction*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class BreakpointAction;
    public:

        Builder<STATE | TypeSet>& setType(Type in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Ref<BreakpointAction> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(BreakpointAction) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<BreakpointAction>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<BreakpointAction> result = BreakpointAction::create()
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setData(const String& in_opt_data)
    {
        JSON::ObjectBase::setString("data"_s, in_opt_data);
    }

    void setId(int in_opt_id)
    {
        JSON::ObjectBase::setInteger("id"_s, in_opt_id);
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* typeKey;
    JS_EXPORT_PRIVATE static const char* dataKey;
    JS_EXPORT_PRIVATE static const char* idKey;
};

/* Extra options that modify breakpoint behavior. */
class BreakpointOptions final : public JSON::Object {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*BreakpointOptions*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class BreakpointOptions;
    public:

        Ref<BreakpointOptions> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(BreakpointOptions) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<BreakpointOptions>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<BreakpointOptions> result = BreakpointOptions::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setCondition(const String& in_opt_condition)
    {
        JSON::ObjectBase::setString("condition"_s, in_opt_condition);
    }

    void setActions(Ref<JSON::ArrayOf<Protocol::Debugger::BreakpointAction>>&& in_opt_actions)
    {
        JSON::ObjectBase::setArray("actions"_s, WTFMove(in_opt_actions));
    }

    void setAutoContinue(bool in_opt_autoContinue)
    {
        JSON::ObjectBase::setBoolean("autoContinue"_s, in_opt_autoContinue);
    }

    void setIgnoreCount(int in_opt_ignoreCount)
    {
        JSON::ObjectBase::setInteger("ignoreCount"_s, in_opt_ignoreCount);
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* conditionKey;
    JS_EXPORT_PRIVATE static const char* actionsKey;
    JS_EXPORT_PRIVATE static const char* autoContinueKey;
    JS_EXPORT_PRIVATE static const char* ignoreCountKey;
};

/* Information about the function. */
class FunctionDetails final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LocationSet = 1 << 0,
        AllFieldsSet = (LocationSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*FunctionDetails*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class FunctionDetails;
    public:

        Builder<STATE | LocationSet>& setLocation(Ref<Protocol::Debugger::Location>&& in_location)
        {
            COMPILE_ASSERT(!(STATE & LocationSet), property_location_already_set);
            m_result->setObject("location"_s, WTFMove(in_location));
            return castState<LocationSet>();
        }

        Ref<FunctionDetails> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(FunctionDetails) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<FunctionDetails>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<FunctionDetails> result = FunctionDetails::create()
     *     .setLocation(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setName(const String& in_opt_name)
    {
        JSON::ObjectBase::setString("name"_s, in_opt_name);
    }

    void setDisplayName(const String& in_opt_displayName)
    {
        JSON::ObjectBase::setString("displayName"_s, in_opt_displayName);
    }

    void setScopeChain(Ref<JSON::ArrayOf<Protocol::Debugger::Scope>>&& in_opt_scopeChain)
    {
        JSON::ObjectBase::setArray("scopeChain"_s, WTFMove(in_opt_scopeChain));
    }
};

/* JavaScript call frame. Array of call frames form the call stack. */
class CallFrame final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        CallFrameIdSet = 1 << 0,
        FunctionNameSet = 1 << 1,
        LocationSet = 1 << 2,
        ScopeChainSet = 1 << 3,
        ThisSet = 1 << 4,
        IsTailDeletedSet = 1 << 5,
        AllFieldsSet = (CallFrameIdSet | FunctionNameSet | LocationSet | ScopeChainSet | ThisSet | IsTailDeletedSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CallFrame*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CallFrame;
    public:

        Builder<STATE | CallFrameIdSet>& setCallFrameId(const String& in_callFrameId)
        {
            COMPILE_ASSERT(!(STATE & CallFrameIdSet), property_callFrameId_already_set);
            m_result->setString("callFrameId"_s, in_callFrameId);
            return castState<CallFrameIdSet>();
        }

        Builder<STATE | FunctionNameSet>& setFunctionName(const String& in_functionName)
        {
            COMPILE_ASSERT(!(STATE & FunctionNameSet), property_functionName_already_set);
            m_result->setString("functionName"_s, in_functionName);
            return castState<FunctionNameSet>();
        }

        Builder<STATE | LocationSet>& setLocation(Ref<Protocol::Debugger::Location>&& in_location)
        {
            COMPILE_ASSERT(!(STATE & LocationSet), property_location_already_set);
            m_result->setObject("location"_s, WTFMove(in_location));
            return castState<LocationSet>();
        }

        Builder<STATE | ScopeChainSet>& setScopeChain(Ref<JSON::ArrayOf<Protocol::Debugger::Scope>>&& in_scopeChain)
        {
            COMPILE_ASSERT(!(STATE & ScopeChainSet), property_scopeChain_already_set);
            m_result->setArray("scopeChain"_s, WTFMove(in_scopeChain));
            return castState<ScopeChainSet>();
        }

        Builder<STATE | ThisSet>& setThis(Ref<Protocol::Runtime::RemoteObject>&& in_this)
        {
            COMPILE_ASSERT(!(STATE & ThisSet), property_this_already_set);
            m_result->setObject("this"_s, WTFMove(in_this));
            return castState<ThisSet>();
        }

        Builder<STATE | IsTailDeletedSet>& setIsTailDeleted(bool in_isTailDeleted)
        {
            COMPILE_ASSERT(!(STATE & IsTailDeletedSet), property_isTailDeleted_already_set);
            m_result->setBoolean("isTailDeleted"_s, in_isTailDeleted);
            return castState<IsTailDeletedSet>();
        }

        Ref<CallFrame> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CallFrame) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CallFrame>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CallFrame> result = CallFrame::create()
     *     .setCallFrameId(...)
     *     .setFunctionName(...)
     *     .setLocation(...)
     *     .setScopeChain(...)
     *     .setThis(...)
     *     .setIsTailDeleted(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Scope description. */
class Scope final : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating Scope.
    enum class Type {
        Global = 119,
        With = 120,
        Closure = 121,
        Catch = 122,
        FunctionName = 123,
        GlobalLexicalEnvironment = 124,
        NestedLexical = 125,
    }; // enum class Type

    enum {
        NoFieldsSet = 0,
        ObjectSet = 1 << 0,
        TypeSet = 1 << 1,
        AllFieldsSet = (ObjectSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Scope*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Scope;
    public:

        Builder<STATE | ObjectSet>& setObject(Ref<Protocol::Runtime::RemoteObject>&& in_object)
        {
            COMPILE_ASSERT(!(STATE & ObjectSet), property_object_already_set);
            m_result->setObject("object"_s, WTFMove(in_object));
            return castState<ObjectSet>();
        }

        Builder<STATE | TypeSet>& setType(Type in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Ref<Scope> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Scope) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Scope>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Scope> result = Scope::create()
     *     .setObject(...)
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setName(const String& in_opt_name)
    {
        JSON::ObjectBase::setString("name"_s, in_opt_name);
    }

    void setLocation(Ref<Protocol::Debugger::Location>&& in_opt_location)
    {
        JSON::ObjectBase::setObject("location"_s, WTFMove(in_opt_location));
    }

    void setEmpty(bool in_opt_empty)
    {
        JSON::ObjectBase::setBoolean("empty"_s, in_opt_empty);
    }
};

/* A sample collected by evaluating a probe breakpoint action. */
class ProbeSample final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ProbeIdSet = 1 << 0,
        SampleIdSet = 1 << 1,
        BatchIdSet = 1 << 2,
        TimestampSet = 1 << 3,
        PayloadSet = 1 << 4,
        AllFieldsSet = (ProbeIdSet | SampleIdSet | BatchIdSet | TimestampSet | PayloadSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ProbeSample*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ProbeSample;
    public:

        Builder<STATE | ProbeIdSet>& setProbeId(int in_probeId)
        {
            COMPILE_ASSERT(!(STATE & ProbeIdSet), property_probeId_already_set);
            m_result->setInteger("probeId"_s, in_probeId);
            return castState<ProbeIdSet>();
        }

        Builder<STATE | SampleIdSet>& setSampleId(int in_sampleId)
        {
            COMPILE_ASSERT(!(STATE & SampleIdSet), property_sampleId_already_set);
            m_result->setInteger("sampleId"_s, in_sampleId);
            return castState<SampleIdSet>();
        }

        Builder<STATE | BatchIdSet>& setBatchId(int in_batchId)
        {
            COMPILE_ASSERT(!(STATE & BatchIdSet), property_batchId_already_set);
            m_result->setInteger("batchId"_s, in_batchId);
            return castState<BatchIdSet>();
        }

        Builder<STATE | TimestampSet>& setTimestamp(double in_timestamp)
        {
            COMPILE_ASSERT(!(STATE & TimestampSet), property_timestamp_already_set);
            m_result->setDouble("timestamp"_s, in_timestamp);
            return castState<TimestampSet>();
        }

        Builder<STATE | PayloadSet>& setPayload(Ref<Protocol::Runtime::RemoteObject>&& in_payload)
        {
            COMPILE_ASSERT(!(STATE & PayloadSet), property_payload_already_set);
            m_result->setObject("payload"_s, WTFMove(in_payload));
            return castState<PayloadSet>();
        }

        Ref<ProbeSample> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ProbeSample) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<ProbeSample>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ProbeSample> result = ProbeSample::create()
     *     .setProbeId(...)
     *     .setSampleId(...)
     *     .setBatchId(...)
     *     .setTimestamp(...)
     *     .setPayload(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* The pause reason auxiliary data when paused because of an assertion. */
class AssertPauseReason final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*AssertPauseReason*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class AssertPauseReason;
    public:

        Ref<AssertPauseReason> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(AssertPauseReason) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<AssertPauseReason>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<AssertPauseReason> result = AssertPauseReason::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setMessage(const String& in_opt_message)
    {
        JSON::ObjectBase::setString("message"_s, in_opt_message);
    }
};

/* The pause reason auxiliary data when paused because of hitting a breakpoint. */
class BreakpointPauseReason final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        BreakpointIdSet = 1 << 0,
        AllFieldsSet = (BreakpointIdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*BreakpointPauseReason*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class BreakpointPauseReason;
    public:

        Builder<STATE | BreakpointIdSet>& setBreakpointId(const String& in_breakpointId)
        {
            COMPILE_ASSERT(!(STATE & BreakpointIdSet), property_breakpointId_already_set);
            m_result->setString("breakpointId"_s, in_breakpointId);
            return castState<BreakpointIdSet>();
        }

        Ref<BreakpointPauseReason> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(BreakpointPauseReason) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<BreakpointPauseReason>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<BreakpointPauseReason> result = BreakpointPauseReason::create()
     *     .setBreakpointId(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* The pause reason auxiliary data when paused because of a Content Security Policy directive. */
class CSPViolationPauseReason final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        DirectiveSet = 1 << 0,
        AllFieldsSet = (DirectiveSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSPViolationPauseReason*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSPViolationPauseReason;
    public:

        Builder<STATE | DirectiveSet>& setDirective(const String& in_directive)
        {
            COMPILE_ASSERT(!(STATE & DirectiveSet), property_directive_already_set);
            m_result->setString("directive"_s, in_directive);
            return castState<DirectiveSet>();
        }

        Ref<CSPViolationPauseReason> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSPViolationPauseReason) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CSPViolationPauseReason>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSPViolationPauseReason> result = CSPViolationPauseReason::create()
     *     .setDirective(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // Debugger

namespace GenericTypes {

/* Search match in a resource. */
class SearchMatch final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LineNumberSet = 1 << 0,
        LineContentSet = 1 << 1,
        AllFieldsSet = (LineNumberSet | LineContentSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*SearchMatch*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class SearchMatch;
    public:

        Builder<STATE | LineNumberSet>& setLineNumber(double in_lineNumber)
        {
            COMPILE_ASSERT(!(STATE & LineNumberSet), property_lineNumber_already_set);
            m_result->setDouble("lineNumber"_s, in_lineNumber);
            return castState<LineNumberSet>();
        }

        Builder<STATE | LineContentSet>& setLineContent(const String& in_lineContent)
        {
            COMPILE_ASSERT(!(STATE & LineContentSet), property_lineContent_already_set);
            m_result->setString("lineContent"_s, in_lineContent);
            return castState<LineContentSet>();
        }

        Ref<SearchMatch> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(SearchMatch) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<SearchMatch>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<SearchMatch> result = SearchMatch::create()
     *     .setLineNumber(...)
     *     .setLineContent(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // GenericTypes

namespace Heap {

/* Information about a garbage collection. */
class GarbageCollection final : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating GarbageCollection.
    enum class Type {
        Full = 126,
        Partial = 127,
    }; // enum class Type

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        StartTimeSet = 1 << 1,
        EndTimeSet = 1 << 2,
        AllFieldsSet = (TypeSet | StartTimeSet | EndTimeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*GarbageCollection*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class GarbageCollection;
    public:

        Builder<STATE | TypeSet>& setType(Type in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Builder<STATE | StartTimeSet>& setStartTime(double in_startTime)
        {
            COMPILE_ASSERT(!(STATE & StartTimeSet), property_startTime_already_set);
            m_result->setDouble("startTime"_s, in_startTime);
            return castState<StartTimeSet>();
        }

        Builder<STATE | EndTimeSet>& setEndTime(double in_endTime)
        {
            COMPILE_ASSERT(!(STATE & EndTimeSet), property_endTime_already_set);
            m_result->setDouble("endTime"_s, in_endTime);
            return castState<EndTimeSet>();
        }

        Ref<GarbageCollection> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(GarbageCollection) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<GarbageCollection>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<GarbageCollection> result = GarbageCollection::create()
     *     .setType(...)
     *     .setStartTime(...)
     *     .setEndTime(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // Heap

#if defined(ENABLE_INDEXED_DATABASE) && ENABLE_INDEXED_DATABASE
namespace IndexedDB {

/* Database with an array of object stores. */
class DatabaseWithObjectStores final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        VersionSet = 1 << 1,
        ObjectStoresSet = 1 << 2,
        AllFieldsSet = (NameSet | VersionSet | ObjectStoresSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*DatabaseWithObjectStores*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class DatabaseWithObjectStores;
    public:

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Builder<STATE | VersionSet>& setVersion(double in_version)
        {
            COMPILE_ASSERT(!(STATE & VersionSet), property_version_already_set);
            m_result->setDouble("version"_s, in_version);
            return castState<VersionSet>();
        }

        Builder<STATE | ObjectStoresSet>& setObjectStores(Ref<JSON::ArrayOf<Protocol::IndexedDB::ObjectStore>>&& in_objectStores)
        {
            COMPILE_ASSERT(!(STATE & ObjectStoresSet), property_objectStores_already_set);
            m_result->setArray("objectStores"_s, WTFMove(in_objectStores));
            return castState<ObjectStoresSet>();
        }

        Ref<DatabaseWithObjectStores> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(DatabaseWithObjectStores) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<DatabaseWithObjectStores>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<DatabaseWithObjectStores> result = DatabaseWithObjectStores::create()
     *     .setName(...)
     *     .setVersion(...)
     *     .setObjectStores(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Object store. */
class ObjectStore final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        KeyPathSet = 1 << 1,
        AutoIncrementSet = 1 << 2,
        IndexesSet = 1 << 3,
        AllFieldsSet = (NameSet | KeyPathSet | AutoIncrementSet | IndexesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ObjectStore*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ObjectStore;
    public:

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Builder<STATE | KeyPathSet>& setKeyPath(Ref<Protocol::IndexedDB::KeyPath>&& in_keyPath)
        {
            COMPILE_ASSERT(!(STATE & KeyPathSet), property_keyPath_already_set);
            m_result->setObject("keyPath"_s, WTFMove(in_keyPath));
            return castState<KeyPathSet>();
        }

        Builder<STATE | AutoIncrementSet>& setAutoIncrement(bool in_autoIncrement)
        {
            COMPILE_ASSERT(!(STATE & AutoIncrementSet), property_autoIncrement_already_set);
            m_result->setBoolean("autoIncrement"_s, in_autoIncrement);
            return castState<AutoIncrementSet>();
        }

        Builder<STATE | IndexesSet>& setIndexes(Ref<JSON::ArrayOf<Protocol::IndexedDB::ObjectStoreIndex>>&& in_indexes)
        {
            COMPILE_ASSERT(!(STATE & IndexesSet), property_indexes_already_set);
            m_result->setArray("indexes"_s, WTFMove(in_indexes));
            return castState<IndexesSet>();
        }

        Ref<ObjectStore> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ObjectStore) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<ObjectStore>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ObjectStore> result = ObjectStore::create()
     *     .setName(...)
     *     .setKeyPath(...)
     *     .setAutoIncrement(...)
     *     .setIndexes(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Object store index. */
class ObjectStoreIndex final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        KeyPathSet = 1 << 1,
        UniqueSet = 1 << 2,
        MultiEntrySet = 1 << 3,
        AllFieldsSet = (NameSet | KeyPathSet | UniqueSet | MultiEntrySet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ObjectStoreIndex*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ObjectStoreIndex;
    public:

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Builder<STATE | KeyPathSet>& setKeyPath(Ref<Protocol::IndexedDB::KeyPath>&& in_keyPath)
        {
            COMPILE_ASSERT(!(STATE & KeyPathSet), property_keyPath_already_set);
            m_result->setObject("keyPath"_s, WTFMove(in_keyPath));
            return castState<KeyPathSet>();
        }

        Builder<STATE | UniqueSet>& setUnique(bool in_unique)
        {
            COMPILE_ASSERT(!(STATE & UniqueSet), property_unique_already_set);
            m_result->setBoolean("unique"_s, in_unique);
            return castState<UniqueSet>();
        }

        Builder<STATE | MultiEntrySet>& setMultiEntry(bool in_multiEntry)
        {
            COMPILE_ASSERT(!(STATE & MultiEntrySet), property_multiEntry_already_set);
            m_result->setBoolean("multiEntry"_s, in_multiEntry);
            return castState<MultiEntrySet>();
        }

        Ref<ObjectStoreIndex> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ObjectStoreIndex) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<ObjectStoreIndex>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ObjectStoreIndex> result = ObjectStoreIndex::create()
     *     .setName(...)
     *     .setKeyPath(...)
     *     .setUnique(...)
     *     .setMultiEntry(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Key. */
class Key final : public JSON::Object {
public:
    // Named after property name 'type' while generating Key.
    enum class Type {
        Number = 128,
        String = 129,
        Date = 103,
        Array = 130,
    }; // enum class Type

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Key*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Key;
    public:

        Builder<STATE | TypeSet>& setType(Type in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Ref<Key> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Key) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Key>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Key> result = Key::create()
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setNumber(double in_opt_number)
    {
        JSON::ObjectBase::setDouble("number"_s, in_opt_number);
    }

    void setString(const String& in_opt_string)
    {
        JSON::ObjectBase::setString("string"_s, in_opt_string);
    }

    void setDate(double in_opt_date)
    {
        JSON::ObjectBase::setDouble("date"_s, in_opt_date);
    }

    void setArray(Ref<JSON::ArrayOf<Protocol::IndexedDB::Key>>&& in_opt_array)
    {
        JSON::ObjectBase::setArray("array"_s, WTFMove(in_opt_array));
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* typeKey;
    JS_EXPORT_PRIVATE static const char* numberKey;
    JS_EXPORT_PRIVATE static const char* stringKey;
    JS_EXPORT_PRIVATE static const char* dateKey;
    JS_EXPORT_PRIVATE static const char* arrayKey;
};

/* Key range. */
class KeyRange final : public JSON::Object {
public:
    enum {
        NoFieldsSet = 0,
        LowerOpenSet = 1 << 0,
        UpperOpenSet = 1 << 1,
        AllFieldsSet = (LowerOpenSet | UpperOpenSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*KeyRange*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class KeyRange;
    public:

        Builder<STATE | LowerOpenSet>& setLowerOpen(bool in_lowerOpen)
        {
            COMPILE_ASSERT(!(STATE & LowerOpenSet), property_lowerOpen_already_set);
            m_result->setBoolean("lowerOpen"_s, in_lowerOpen);
            return castState<LowerOpenSet>();
        }

        Builder<STATE | UpperOpenSet>& setUpperOpen(bool in_upperOpen)
        {
            COMPILE_ASSERT(!(STATE & UpperOpenSet), property_upperOpen_already_set);
            m_result->setBoolean("upperOpen"_s, in_upperOpen);
            return castState<UpperOpenSet>();
        }

        Ref<KeyRange> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(KeyRange) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<KeyRange>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<KeyRange> result = KeyRange::create()
     *     .setLowerOpen(...)
     *     .setUpperOpen(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setLower(Ref<Protocol::IndexedDB::Key>&& in_opt_lower)
    {
        JSON::ObjectBase::setObject("lower"_s, WTFMove(in_opt_lower));
    }

    void setUpper(Ref<Protocol::IndexedDB::Key>&& in_opt_upper)
    {
        JSON::ObjectBase::setObject("upper"_s, WTFMove(in_opt_upper));
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* lowerKey;
    JS_EXPORT_PRIVATE static const char* upperKey;
    JS_EXPORT_PRIVATE static const char* lowerOpenKey;
    JS_EXPORT_PRIVATE static const char* upperOpenKey;
};

/* Data entry. */
class DataEntry final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        KeySet = 1 << 0,
        PrimaryKeySet = 1 << 1,
        ValueSet = 1 << 2,
        AllFieldsSet = (KeySet | PrimaryKeySet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*DataEntry*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class DataEntry;
    public:

        Builder<STATE | KeySet>& setKey(Ref<Protocol::Runtime::RemoteObject>&& in_key)
        {
            COMPILE_ASSERT(!(STATE & KeySet), property_key_already_set);
            m_result->setObject("key"_s, WTFMove(in_key));
            return castState<KeySet>();
        }

        Builder<STATE | PrimaryKeySet>& setPrimaryKey(Ref<Protocol::Runtime::RemoteObject>&& in_primaryKey)
        {
            COMPILE_ASSERT(!(STATE & PrimaryKeySet), property_primaryKey_already_set);
            m_result->setObject("primaryKey"_s, WTFMove(in_primaryKey));
            return castState<PrimaryKeySet>();
        }

        Builder<STATE | ValueSet>& setValue(Ref<Protocol::Runtime::RemoteObject>&& in_value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setObject("value"_s, WTFMove(in_value));
            return castState<ValueSet>();
        }

        Ref<DataEntry> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(DataEntry) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<DataEntry>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<DataEntry> result = DataEntry::create()
     *     .setKey(...)
     *     .setPrimaryKey(...)
     *     .setValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Key path. */
class KeyPath final : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating KeyPath.
    enum class Type {
        Null = 131,
        String = 129,
        Array = 130,
    }; // enum class Type

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*KeyPath*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class KeyPath;
    public:

        Builder<STATE | TypeSet>& setType(Type in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Ref<KeyPath> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(KeyPath) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<KeyPath>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<KeyPath> result = KeyPath::create()
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setString(const String& in_opt_string)
    {
        JSON::ObjectBase::setString("string"_s, in_opt_string);
    }

    void setArray(Ref<JSON::ArrayOf<String>>&& in_opt_array)
    {
        JSON::ObjectBase::setArray("array"_s, WTFMove(in_opt_array));
    }
};

} // IndexedDB
#endif // defined(ENABLE_INDEXED_DATABASE) && ENABLE_INDEXED_DATABASE

namespace LayerTree {

/* A rectangle. */
class IntRect final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        XSet = 1 << 0,
        YSet = 1 << 1,
        WidthSet = 1 << 2,
        HeightSet = 1 << 3,
        AllFieldsSet = (XSet | YSet | WidthSet | HeightSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*IntRect*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class IntRect;
    public:

        Builder<STATE | XSet>& setX(int in_x)
        {
            COMPILE_ASSERT(!(STATE & XSet), property_x_already_set);
            m_result->setInteger("x"_s, in_x);
            return castState<XSet>();
        }

        Builder<STATE | YSet>& setY(int in_y)
        {
            COMPILE_ASSERT(!(STATE & YSet), property_y_already_set);
            m_result->setInteger("y"_s, in_y);
            return castState<YSet>();
        }

        Builder<STATE | WidthSet>& setWidth(int in_width)
        {
            COMPILE_ASSERT(!(STATE & WidthSet), property_width_already_set);
            m_result->setInteger("width"_s, in_width);
            return castState<WidthSet>();
        }

        Builder<STATE | HeightSet>& setHeight(int in_height)
        {
            COMPILE_ASSERT(!(STATE & HeightSet), property_height_already_set);
            m_result->setInteger("height"_s, in_height);
            return castState<HeightSet>();
        }

        Ref<IntRect> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(IntRect) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<IntRect>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<IntRect> result = IntRect::create()
     *     .setX(...)
     *     .setY(...)
     *     .setWidth(...)
     *     .setHeight(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Information about a compositing layer. */
class Layer final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LayerIdSet = 1 << 0,
        NodeIdSet = 1 << 1,
        BoundsSet = 1 << 2,
        PaintCountSet = 1 << 3,
        MemorySet = 1 << 4,
        CompositedBoundsSet = 1 << 5,
        AllFieldsSet = (LayerIdSet | NodeIdSet | BoundsSet | PaintCountSet | MemorySet | CompositedBoundsSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Layer*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Layer;
    public:

        Builder<STATE | LayerIdSet>& setLayerId(const String& in_layerId)
        {
            COMPILE_ASSERT(!(STATE & LayerIdSet), property_layerId_already_set);
            m_result->setString("layerId"_s, in_layerId);
            return castState<LayerIdSet>();
        }

        Builder<STATE | NodeIdSet>& setNodeId(int in_nodeId)
        {
            COMPILE_ASSERT(!(STATE & NodeIdSet), property_nodeId_already_set);
            m_result->setInteger("nodeId"_s, in_nodeId);
            return castState<NodeIdSet>();
        }

        Builder<STATE | BoundsSet>& setBounds(Ref<Protocol::LayerTree::IntRect>&& in_bounds)
        {
            COMPILE_ASSERT(!(STATE & BoundsSet), property_bounds_already_set);
            m_result->setObject("bounds"_s, WTFMove(in_bounds));
            return castState<BoundsSet>();
        }

        Builder<STATE | PaintCountSet>& setPaintCount(int in_paintCount)
        {
            COMPILE_ASSERT(!(STATE & PaintCountSet), property_paintCount_already_set);
            m_result->setInteger("paintCount"_s, in_paintCount);
            return castState<PaintCountSet>();
        }

        Builder<STATE | MemorySet>& setMemory(int in_memory)
        {
            COMPILE_ASSERT(!(STATE & MemorySet), property_memory_already_set);
            m_result->setInteger("memory"_s, in_memory);
            return castState<MemorySet>();
        }

        Builder<STATE | CompositedBoundsSet>& setCompositedBounds(Ref<Protocol::LayerTree::IntRect>&& in_compositedBounds)
        {
            COMPILE_ASSERT(!(STATE & CompositedBoundsSet), property_compositedBounds_already_set);
            m_result->setObject("compositedBounds"_s, WTFMove(in_compositedBounds));
            return castState<CompositedBoundsSet>();
        }

        Ref<Layer> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Layer) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Layer>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Layer> result = Layer::create()
     *     .setLayerId(...)
     *     .setNodeId(...)
     *     .setBounds(...)
     *     .setPaintCount(...)
     *     .setMemory(...)
     *     .setCompositedBounds(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setIsInShadowTree(bool in_opt_isInShadowTree)
    {
        JSON::ObjectBase::setBoolean("isInShadowTree"_s, in_opt_isInShadowTree);
    }

    void setIsReflection(bool in_opt_isReflection)
    {
        JSON::ObjectBase::setBoolean("isReflection"_s, in_opt_isReflection);
    }

    void setIsGeneratedContent(bool in_opt_isGeneratedContent)
    {
        JSON::ObjectBase::setBoolean("isGeneratedContent"_s, in_opt_isGeneratedContent);
    }

    void setIsAnonymous(bool in_opt_isAnonymous)
    {
        JSON::ObjectBase::setBoolean("isAnonymous"_s, in_opt_isAnonymous);
    }

    void setPseudoElementId(const String& in_opt_pseudoElementId)
    {
        JSON::ObjectBase::setString("pseudoElementId"_s, in_opt_pseudoElementId);
    }

    void setPseudoElement(const String& in_opt_pseudoElement)
    {
        JSON::ObjectBase::setString("pseudoElement"_s, in_opt_pseudoElement);
    }
};

/* An object containing the reasons why the layer was composited as properties. */
class CompositingReasons final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CompositingReasons*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CompositingReasons;
    public:

        Ref<CompositingReasons> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CompositingReasons) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CompositingReasons>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CompositingReasons> result = CompositingReasons::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setTransform3D(bool in_opt_transform3D)
    {
        JSON::ObjectBase::setBoolean("transform3D"_s, in_opt_transform3D);
    }

    void setVideo(bool in_opt_video)
    {
        JSON::ObjectBase::setBoolean("video"_s, in_opt_video);
    }

    void setCanvas(bool in_opt_canvas)
    {
        JSON::ObjectBase::setBoolean("canvas"_s, in_opt_canvas);
    }

    void setPlugin(bool in_opt_plugin)
    {
        JSON::ObjectBase::setBoolean("plugin"_s, in_opt_plugin);
    }

    void setIFrame(bool in_opt_iFrame)
    {
        JSON::ObjectBase::setBoolean("iFrame"_s, in_opt_iFrame);
    }

    void setBackfaceVisibilityHidden(bool in_opt_backfaceVisibilityHidden)
    {
        JSON::ObjectBase::setBoolean("backfaceVisibilityHidden"_s, in_opt_backfaceVisibilityHidden);
    }

    void setClipsCompositingDescendants(bool in_opt_clipsCompositingDescendants)
    {
        JSON::ObjectBase::setBoolean("clipsCompositingDescendants"_s, in_opt_clipsCompositingDescendants);
    }

    void setAnimation(bool in_opt_animation)
    {
        JSON::ObjectBase::setBoolean("animation"_s, in_opt_animation);
    }

    void setFilters(bool in_opt_filters)
    {
        JSON::ObjectBase::setBoolean("filters"_s, in_opt_filters);
    }

    void setPositionFixed(bool in_opt_positionFixed)
    {
        JSON::ObjectBase::setBoolean("positionFixed"_s, in_opt_positionFixed);
    }

    void setPositionSticky(bool in_opt_positionSticky)
    {
        JSON::ObjectBase::setBoolean("positionSticky"_s, in_opt_positionSticky);
    }

    void setOverflowScrollingTouch(bool in_opt_overflowScrollingTouch)
    {
        JSON::ObjectBase::setBoolean("overflowScrollingTouch"_s, in_opt_overflowScrollingTouch);
    }

    void setStacking(bool in_opt_stacking)
    {
        JSON::ObjectBase::setBoolean("stacking"_s, in_opt_stacking);
    }

    void setOverlap(bool in_opt_overlap)
    {
        JSON::ObjectBase::setBoolean("overlap"_s, in_opt_overlap);
    }

    void setNegativeZIndexChildren(bool in_opt_negativeZIndexChildren)
    {
        JSON::ObjectBase::setBoolean("negativeZIndexChildren"_s, in_opt_negativeZIndexChildren);
    }

    void setTransformWithCompositedDescendants(bool in_opt_transformWithCompositedDescendants)
    {
        JSON::ObjectBase::setBoolean("transformWithCompositedDescendants"_s, in_opt_transformWithCompositedDescendants);
    }

    void setOpacityWithCompositedDescendants(bool in_opt_opacityWithCompositedDescendants)
    {
        JSON::ObjectBase::setBoolean("opacityWithCompositedDescendants"_s, in_opt_opacityWithCompositedDescendants);
    }

    void setMaskWithCompositedDescendants(bool in_opt_maskWithCompositedDescendants)
    {
        JSON::ObjectBase::setBoolean("maskWithCompositedDescendants"_s, in_opt_maskWithCompositedDescendants);
    }

    void setReflectionWithCompositedDescendants(bool in_opt_reflectionWithCompositedDescendants)
    {
        JSON::ObjectBase::setBoolean("reflectionWithCompositedDescendants"_s, in_opt_reflectionWithCompositedDescendants);
    }

    void setFilterWithCompositedDescendants(bool in_opt_filterWithCompositedDescendants)
    {
        JSON::ObjectBase::setBoolean("filterWithCompositedDescendants"_s, in_opt_filterWithCompositedDescendants);
    }

    void setBlendingWithCompositedDescendants(bool in_opt_blendingWithCompositedDescendants)
    {
        JSON::ObjectBase::setBoolean("blendingWithCompositedDescendants"_s, in_opt_blendingWithCompositedDescendants);
    }

    void setIsolatesCompositedBlendingDescendants(bool in_opt_isolatesCompositedBlendingDescendants)
    {
        JSON::ObjectBase::setBoolean("isolatesCompositedBlendingDescendants"_s, in_opt_isolatesCompositedBlendingDescendants);
    }

    void setPerspective(bool in_opt_perspective)
    {
        JSON::ObjectBase::setBoolean("perspective"_s, in_opt_perspective);
    }

    void setPreserve3D(bool in_opt_preserve3D)
    {
        JSON::ObjectBase::setBoolean("preserve3D"_s, in_opt_preserve3D);
    }

    void setWillChange(bool in_opt_willChange)
    {
        JSON::ObjectBase::setBoolean("willChange"_s, in_opt_willChange);
    }

    void setRoot(bool in_opt_root)
    {
        JSON::ObjectBase::setBoolean("root"_s, in_opt_root);
    }

    void setBlending(bool in_opt_blending)
    {
        JSON::ObjectBase::setBoolean("blending"_s, in_opt_blending);
    }
};

} // LayerTree

#if defined(ENABLE_RESOURCE_USAGE) && ENABLE_RESOURCE_USAGE
namespace Memory {

class Event final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TimestampSet = 1 << 0,
        CategoriesSet = 1 << 1,
        AllFieldsSet = (TimestampSet | CategoriesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Event*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Event;
    public:

        Builder<STATE | TimestampSet>& setTimestamp(double in_timestamp)
        {
            COMPILE_ASSERT(!(STATE & TimestampSet), property_timestamp_already_set);
            m_result->setDouble("timestamp"_s, in_timestamp);
            return castState<TimestampSet>();
        }

        Builder<STATE | CategoriesSet>& setCategories(Ref<JSON::ArrayOf<Protocol::Memory::CategoryData>>&& in_categories)
        {
            COMPILE_ASSERT(!(STATE & CategoriesSet), property_categories_already_set);
            m_result->setArray("categories"_s, WTFMove(in_categories));
            return castState<CategoriesSet>();
        }

        Ref<Event> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Event) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Event>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Event> result = Event::create()
     *     .setTimestamp(...)
     *     .setCategories(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

class CategoryData final : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating CategoryData.
    enum class Type {
        JavaScript = 52,
        JIT = 132,
        Images = 133,
        Layers = 134,
        Page = 100,
        Other = 66,
    }; // enum class Type

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        SizeSet = 1 << 1,
        AllFieldsSet = (TypeSet | SizeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CategoryData*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CategoryData;
    public:

        Builder<STATE | TypeSet>& setType(Type in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Builder<STATE | SizeSet>& setSize(double in_size)
        {
            COMPILE_ASSERT(!(STATE & SizeSet), property_size_already_set);
            m_result->setDouble("size"_s, in_size);
            return castState<SizeSet>();
        }

        Ref<CategoryData> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CategoryData) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CategoryData>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CategoryData> result = CategoryData::create()
     *     .setType(...)
     *     .setSize(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // Memory
#endif // defined(ENABLE_RESOURCE_USAGE) && ENABLE_RESOURCE_USAGE

namespace Network {

/* Request / response headers as keys / values of JSON object. */
class Headers final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Headers*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Headers;
    public:

        Ref<Headers> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Headers) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Headers>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Headers> result = Headers::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Timing information for the request. */
class ResourceTiming final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StartTimeSet = 1 << 0,
        RedirectStartSet = 1 << 1,
        RedirectEndSet = 1 << 2,
        FetchStartSet = 1 << 3,
        DomainLookupStartSet = 1 << 4,
        DomainLookupEndSet = 1 << 5,
        ConnectStartSet = 1 << 6,
        ConnectEndSet = 1 << 7,
        SecureConnectionStartSet = 1 << 8,
        RequestStartSet = 1 << 9,
        ResponseStartSet = 1 << 10,
        ResponseEndSet = 1 << 11,
        AllFieldsSet = (StartTimeSet | RedirectStartSet | RedirectEndSet | FetchStartSet | DomainLookupStartSet | DomainLookupEndSet | ConnectStartSet | ConnectEndSet | SecureConnectionStartSet | RequestStartSet | ResponseStartSet | ResponseEndSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ResourceTiming*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ResourceTiming;
    public:

        Builder<STATE | StartTimeSet>& setStartTime(double in_startTime)
        {
            COMPILE_ASSERT(!(STATE & StartTimeSet), property_startTime_already_set);
            m_result->setDouble("startTime"_s, in_startTime);
            return castState<StartTimeSet>();
        }

        Builder<STATE | RedirectStartSet>& setRedirectStart(double in_redirectStart)
        {
            COMPILE_ASSERT(!(STATE & RedirectStartSet), property_redirectStart_already_set);
            m_result->setDouble("redirectStart"_s, in_redirectStart);
            return castState<RedirectStartSet>();
        }

        Builder<STATE | RedirectEndSet>& setRedirectEnd(double in_redirectEnd)
        {
            COMPILE_ASSERT(!(STATE & RedirectEndSet), property_redirectEnd_already_set);
            m_result->setDouble("redirectEnd"_s, in_redirectEnd);
            return castState<RedirectEndSet>();
        }

        Builder<STATE | FetchStartSet>& setFetchStart(double in_fetchStart)
        {
            COMPILE_ASSERT(!(STATE & FetchStartSet), property_fetchStart_already_set);
            m_result->setDouble("fetchStart"_s, in_fetchStart);
            return castState<FetchStartSet>();
        }

        Builder<STATE | DomainLookupStartSet>& setDomainLookupStart(double in_domainLookupStart)
        {
            COMPILE_ASSERT(!(STATE & DomainLookupStartSet), property_domainLookupStart_already_set);
            m_result->setDouble("domainLookupStart"_s, in_domainLookupStart);
            return castState<DomainLookupStartSet>();
        }

        Builder<STATE | DomainLookupEndSet>& setDomainLookupEnd(double in_domainLookupEnd)
        {
            COMPILE_ASSERT(!(STATE & DomainLookupEndSet), property_domainLookupEnd_already_set);
            m_result->setDouble("domainLookupEnd"_s, in_domainLookupEnd);
            return castState<DomainLookupEndSet>();
        }

        Builder<STATE | ConnectStartSet>& setConnectStart(double in_connectStart)
        {
            COMPILE_ASSERT(!(STATE & ConnectStartSet), property_connectStart_already_set);
            m_result->setDouble("connectStart"_s, in_connectStart);
            return castState<ConnectStartSet>();
        }

        Builder<STATE | ConnectEndSet>& setConnectEnd(double in_connectEnd)
        {
            COMPILE_ASSERT(!(STATE & ConnectEndSet), property_connectEnd_already_set);
            m_result->setDouble("connectEnd"_s, in_connectEnd);
            return castState<ConnectEndSet>();
        }

        Builder<STATE | SecureConnectionStartSet>& setSecureConnectionStart(double in_secureConnectionStart)
        {
            COMPILE_ASSERT(!(STATE & SecureConnectionStartSet), property_secureConnectionStart_already_set);
            m_result->setDouble("secureConnectionStart"_s, in_secureConnectionStart);
            return castState<SecureConnectionStartSet>();
        }

        Builder<STATE | RequestStartSet>& setRequestStart(double in_requestStart)
        {
            COMPILE_ASSERT(!(STATE & RequestStartSet), property_requestStart_already_set);
            m_result->setDouble("requestStart"_s, in_requestStart);
            return castState<RequestStartSet>();
        }

        Builder<STATE | ResponseStartSet>& setResponseStart(double in_responseStart)
        {
            COMPILE_ASSERT(!(STATE & ResponseStartSet), property_responseStart_already_set);
            m_result->setDouble("responseStart"_s, in_responseStart);
            return castState<ResponseStartSet>();
        }

        Builder<STATE | ResponseEndSet>& setResponseEnd(double in_responseEnd)
        {
            COMPILE_ASSERT(!(STATE & ResponseEndSet), property_responseEnd_already_set);
            m_result->setDouble("responseEnd"_s, in_responseEnd);
            return castState<ResponseEndSet>();
        }

        Ref<ResourceTiming> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ResourceTiming) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<ResourceTiming>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ResourceTiming> result = ResourceTiming::create()
     *     .setStartTime(...)
     *     .setRedirectStart(...)
     *     .setRedirectEnd(...)
     *     .setFetchStart(...)
     *     .setDomainLookupStart(...)
     *     .setDomainLookupEnd(...)
     *     .setConnectStart(...)
     *     .setConnectEnd(...)
     *     .setSecureConnectionStart(...)
     *     .setRequestStart(...)
     *     .setResponseStart(...)
     *     .setResponseEnd(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* HTTP request data. */
class Request final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        MethodSet = 1 << 1,
        HeadersSet = 1 << 2,
        AllFieldsSet = (UrlSet | MethodSet | HeadersSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Request*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Request;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& in_url)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url"_s, in_url);
            return castState<UrlSet>();
        }

        Builder<STATE | MethodSet>& setMethod(const String& in_method)
        {
            COMPILE_ASSERT(!(STATE & MethodSet), property_method_already_set);
            m_result->setString("method"_s, in_method);
            return castState<MethodSet>();
        }

        Builder<STATE | HeadersSet>& setHeaders(Ref<Protocol::Network::Headers>&& in_headers)
        {
            COMPILE_ASSERT(!(STATE & HeadersSet), property_headers_already_set);
            m_result->setObject("headers"_s, WTFMove(in_headers));
            return castState<HeadersSet>();
        }

        Ref<Request> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Request) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Request>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Request> result = Request::create()
     *     .setUrl(...)
     *     .setMethod(...)
     *     .setHeaders(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setPostData(const String& in_opt_postData)
    {
        JSON::ObjectBase::setString("postData"_s, in_opt_postData);
    }
};

/* HTTP response data. */
class Response final : public JSON::Object {
public:
    // Named after property name 'source' while generating Response.
    enum class Source {
        Unknown = 135,
        Network = 53,
        MemoryCache = 136,
        DiskCache = 137,
        ServiceWorker = 138,
        InspectorOverride = 139,
    }; // enum class Source

    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        StatusSet = 1 << 1,
        StatusTextSet = 1 << 2,
        HeadersSet = 1 << 3,
        MimeTypeSet = 1 << 4,
        SourceSet = 1 << 5,
        AllFieldsSet = (UrlSet | StatusSet | StatusTextSet | HeadersSet | MimeTypeSet | SourceSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Response*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Response;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& in_url)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url"_s, in_url);
            return castState<UrlSet>();
        }

        Builder<STATE | StatusSet>& setStatus(int in_status)
        {
            COMPILE_ASSERT(!(STATE & StatusSet), property_status_already_set);
            m_result->setInteger("status"_s, in_status);
            return castState<StatusSet>();
        }

        Builder<STATE | StatusTextSet>& setStatusText(const String& in_statusText)
        {
            COMPILE_ASSERT(!(STATE & StatusTextSet), property_statusText_already_set);
            m_result->setString("statusText"_s, in_statusText);
            return castState<StatusTextSet>();
        }

        Builder<STATE | HeadersSet>& setHeaders(Ref<Protocol::Network::Headers>&& in_headers)
        {
            COMPILE_ASSERT(!(STATE & HeadersSet), property_headers_already_set);
            m_result->setObject("headers"_s, WTFMove(in_headers));
            return castState<HeadersSet>();
        }

        Builder<STATE | MimeTypeSet>& setMimeType(const String& in_mimeType)
        {
            COMPILE_ASSERT(!(STATE & MimeTypeSet), property_mimeType_already_set);
            m_result->setString("mimeType"_s, in_mimeType);
            return castState<MimeTypeSet>();
        }

        Builder<STATE | SourceSet>& setSource(Source in_source)
        {
            COMPILE_ASSERT(!(STATE & SourceSet), property_source_already_set);
            m_result->setString("source"_s, Protocol::Helpers::getEnumConstantValue(in_source));
            return castState<SourceSet>();
        }

        Ref<Response> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Response) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Response>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Response> result = Response::create()
     *     .setUrl(...)
     *     .setStatus(...)
     *     .setStatusText(...)
     *     .setHeaders(...)
     *     .setMimeType(...)
     *     .setSource(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setRequestHeaders(Ref<Protocol::Network::Headers>&& in_opt_requestHeaders)
    {
        JSON::ObjectBase::setObject("requestHeaders"_s, WTFMove(in_opt_requestHeaders));
    }

    void setTiming(Ref<Protocol::Network::ResourceTiming>&& in_opt_timing)
    {
        JSON::ObjectBase::setObject("timing"_s, WTFMove(in_opt_timing));
    }

    void setSecurity(Ref<Protocol::Security::Security>&& in_opt_security)
    {
        JSON::ObjectBase::setObject("security"_s, WTFMove(in_opt_security));
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* statusKey;
    JS_EXPORT_PRIVATE static const char* statusTextKey;
    JS_EXPORT_PRIVATE static const char* mimeTypeKey;
    JS_EXPORT_PRIVATE static const char* sourceKey;
};

/* Network load metrics. */
class Metrics final : public JSON::ObjectBase {
public:
    // Named after property name 'priority' while generating Metrics.
    enum class Priority {
        Low = 140,
        Medium = 141,
        High = 142,
    }; // enum class Priority

    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Metrics*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Metrics;
    public:

        Ref<Metrics> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Metrics) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Metrics>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Metrics> result = Metrics::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setProtocol(const String& in_opt_protocol)
    {
        JSON::ObjectBase::setString("protocol"_s, in_opt_protocol);
    }

    void setPriority(Priority in_opt_priority)
    {
        JSON::ObjectBase::setString("priority"_s, Protocol::Helpers::getEnumConstantValue(in_opt_priority));
    }

    void setConnectionIdentifier(const String& in_opt_connectionIdentifier)
    {
        JSON::ObjectBase::setString("connectionIdentifier"_s, in_opt_connectionIdentifier);
    }

    void setRemoteAddress(const String& in_opt_remoteAddress)
    {
        JSON::ObjectBase::setString("remoteAddress"_s, in_opt_remoteAddress);
    }

    void setRequestHeaders(Ref<Protocol::Network::Headers>&& in_opt_requestHeaders)
    {
        JSON::ObjectBase::setObject("requestHeaders"_s, WTFMove(in_opt_requestHeaders));
    }

    void setRequestHeaderBytesSent(double in_opt_requestHeaderBytesSent)
    {
        JSON::ObjectBase::setDouble("requestHeaderBytesSent"_s, in_opt_requestHeaderBytesSent);
    }

    void setRequestBodyBytesSent(double in_opt_requestBodyBytesSent)
    {
        JSON::ObjectBase::setDouble("requestBodyBytesSent"_s, in_opt_requestBodyBytesSent);
    }

    void setResponseHeaderBytesReceived(double in_opt_responseHeaderBytesReceived)
    {
        JSON::ObjectBase::setDouble("responseHeaderBytesReceived"_s, in_opt_responseHeaderBytesReceived);
    }

    void setResponseBodyBytesReceived(double in_opt_responseBodyBytesReceived)
    {
        JSON::ObjectBase::setDouble("responseBodyBytesReceived"_s, in_opt_responseBodyBytesReceived);
    }

    void setResponseBodyDecodedSize(double in_opt_responseBodyDecodedSize)
    {
        JSON::ObjectBase::setDouble("responseBodyDecodedSize"_s, in_opt_responseBodyDecodedSize);
    }

    void setSecurityConnection(Ref<Protocol::Security::Connection>&& in_opt_securityConnection)
    {
        JSON::ObjectBase::setObject("securityConnection"_s, WTFMove(in_opt_securityConnection));
    }
};

/* WebSocket request data. */
class WebSocketRequest final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        HeadersSet = 1 << 0,
        AllFieldsSet = (HeadersSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*WebSocketRequest*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class WebSocketRequest;
    public:

        Builder<STATE | HeadersSet>& setHeaders(Ref<Protocol::Network::Headers>&& in_headers)
        {
            COMPILE_ASSERT(!(STATE & HeadersSet), property_headers_already_set);
            m_result->setObject("headers"_s, WTFMove(in_headers));
            return castState<HeadersSet>();
        }

        Ref<WebSocketRequest> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(WebSocketRequest) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<WebSocketRequest>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<WebSocketRequest> result = WebSocketRequest::create()
     *     .setHeaders(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* WebSocket response data. */
class WebSocketResponse final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StatusSet = 1 << 0,
        StatusTextSet = 1 << 1,
        HeadersSet = 1 << 2,
        AllFieldsSet = (StatusSet | StatusTextSet | HeadersSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*WebSocketResponse*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class WebSocketResponse;
    public:

        Builder<STATE | StatusSet>& setStatus(int in_status)
        {
            COMPILE_ASSERT(!(STATE & StatusSet), property_status_already_set);
            m_result->setInteger("status"_s, in_status);
            return castState<StatusSet>();
        }

        Builder<STATE | StatusTextSet>& setStatusText(const String& in_statusText)
        {
            COMPILE_ASSERT(!(STATE & StatusTextSet), property_statusText_already_set);
            m_result->setString("statusText"_s, in_statusText);
            return castState<StatusTextSet>();
        }

        Builder<STATE | HeadersSet>& setHeaders(Ref<Protocol::Network::Headers>&& in_headers)
        {
            COMPILE_ASSERT(!(STATE & HeadersSet), property_headers_already_set);
            m_result->setObject("headers"_s, WTFMove(in_headers));
            return castState<HeadersSet>();
        }

        Ref<WebSocketResponse> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(WebSocketResponse) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<WebSocketResponse>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<WebSocketResponse> result = WebSocketResponse::create()
     *     .setStatus(...)
     *     .setStatusText(...)
     *     .setHeaders(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* WebSocket frame data. */
class WebSocketFrame final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        OpcodeSet = 1 << 0,
        MaskSet = 1 << 1,
        PayloadDataSet = 1 << 2,
        PayloadLengthSet = 1 << 3,
        AllFieldsSet = (OpcodeSet | MaskSet | PayloadDataSet | PayloadLengthSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*WebSocketFrame*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class WebSocketFrame;
    public:

        Builder<STATE | OpcodeSet>& setOpcode(double in_opcode)
        {
            COMPILE_ASSERT(!(STATE & OpcodeSet), property_opcode_already_set);
            m_result->setDouble("opcode"_s, in_opcode);
            return castState<OpcodeSet>();
        }

        Builder<STATE | MaskSet>& setMask(bool in_mask)
        {
            COMPILE_ASSERT(!(STATE & MaskSet), property_mask_already_set);
            m_result->setBoolean("mask"_s, in_mask);
            return castState<MaskSet>();
        }

        Builder<STATE | PayloadDataSet>& setPayloadData(const String& in_payloadData)
        {
            COMPILE_ASSERT(!(STATE & PayloadDataSet), property_payloadData_already_set);
            m_result->setString("payloadData"_s, in_payloadData);
            return castState<PayloadDataSet>();
        }

        Builder<STATE | PayloadLengthSet>& setPayloadLength(double in_payloadLength)
        {
            COMPILE_ASSERT(!(STATE & PayloadLengthSet), property_payloadLength_already_set);
            m_result->setDouble("payloadLength"_s, in_payloadLength);
            return castState<PayloadLengthSet>();
        }

        Ref<WebSocketFrame> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(WebSocketFrame) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<WebSocketFrame>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<WebSocketFrame> result = WebSocketFrame::create()
     *     .setOpcode(...)
     *     .setMask(...)
     *     .setPayloadData(...)
     *     .setPayloadLength(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Information about the cached resource. */
class CachedResource final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        TypeSet = 1 << 1,
        BodySizeSet = 1 << 2,
        AllFieldsSet = (UrlSet | TypeSet | BodySizeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CachedResource*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CachedResource;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& in_url)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url"_s, in_url);
            return castState<UrlSet>();
        }

        Builder<STATE | TypeSet>& setType(Protocol::Page::ResourceType in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Builder<STATE | BodySizeSet>& setBodySize(double in_bodySize)
        {
            COMPILE_ASSERT(!(STATE & BodySizeSet), property_bodySize_already_set);
            m_result->setDouble("bodySize"_s, in_bodySize);
            return castState<BodySizeSet>();
        }

        Ref<CachedResource> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CachedResource) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CachedResource>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CachedResource> result = CachedResource::create()
     *     .setUrl(...)
     *     .setType(...)
     *     .setBodySize(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setResponse(Ref<Protocol::Network::Response>&& in_opt_response)
    {
        JSON::ObjectBase::setObject("response"_s, WTFMove(in_opt_response));
    }

    void setSourceMapURL(const String& in_opt_sourceMapURL)
    {
        JSON::ObjectBase::setString("sourceMapURL"_s, in_opt_sourceMapURL);
    }
};

/* Information about the request initiator. */
class Initiator final : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating Initiator.
    enum class Type {
        Parser = 154,
        Script = 155,
        Other = 66,
    }; // enum class Type

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Initiator*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Initiator;
    public:

        Builder<STATE | TypeSet>& setType(Type in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Ref<Initiator> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Initiator) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Initiator>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Initiator> result = Initiator::create()
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setStackTrace(Ref<JSON::ArrayOf<Protocol::Console::CallFrame>>&& in_opt_stackTrace)
    {
        JSON::ObjectBase::setArray("stackTrace"_s, WTFMove(in_opt_stackTrace));
    }

    void setUrl(const String& in_opt_url)
    {
        JSON::ObjectBase::setString("url"_s, in_opt_url);
    }

    void setLineNumber(double in_opt_lineNumber)
    {
        JSON::ObjectBase::setDouble("lineNumber"_s, in_opt_lineNumber);
    }

    void setNodeId(int in_opt_nodeId)
    {
        JSON::ObjectBase::setInteger("nodeId"_s, in_opt_nodeId);
    }
};

/* Different stages of a network request. */
enum class NetworkStage {
    Request = 156,
    Response = 157,
}; // enum class NetworkStage

/* Different stages of a network request. */
enum class ResourceErrorType {
    General = 158,
    AccessControl = 159,
    Cancellation = 160,
    Timeout = 161,
}; // enum class ResourceErrorType

} // Network

namespace Page {

/* List of settings able to be overridden by WebInspector. */
enum class Setting {
    AdClickAttributionDebugModeEnabled = 162,
    AuthorAndUserStylesEnabled = 163,
    ICECandidateFilteringEnabled = 164,
    ITPDebugModeEnabled = 165,
    ImagesEnabled = 166,
    MediaCaptureRequiresSecureConnection = 167,
    MockCaptureDevicesEnabled = 168,
    NeedsSiteSpecificQuirks = 169,
    ScriptEnabled = 170,
    ShowDebugBorders = 171,
    ShowRepaintCounter = 172,
    WebRTCEncryptionEnabled = 173,
    WebSecurityEnabled = 174,
}; // enum class Setting

/* Resource type as it was perceived by the rendering engine. */
enum class ResourceType {
    Document = 143,
    StyleSheet = 144,
    Image = 145,
    Font = 146,
    Script = 147,
    XHR = 148,
    Fetch = 149,
    Ping = 150,
    Beacon = 151,
    WebSocket = 152,
    Other = 153,
}; // enum class ResourceType

/* Coordinate system used by supplied coordinates. */
enum class CoordinateSystem {
    Viewport = 175,
    Page = 176,
}; // enum class CoordinateSystem

/* Same-Site policy of a cookie. */
enum class CookieSameSitePolicy {
    None = 177,
    Lax = 178,
    Strict = 179,
}; // enum class CookieSameSitePolicy

#if (defined(ENABLE_DARK_MODE_CSS) && ENABLE_DARK_MODE_CSS) || (defined(HAVE_OS_DARK_MODE_SUPPORT) && HAVE_OS_DARK_MODE_SUPPORT)
/* Page appearance name. */
enum class Appearance {
    Light = 180,
    Dark = 181,
}; // enum class Appearance
#endif // (defined(ENABLE_DARK_MODE_CSS) && ENABLE_DARK_MODE_CSS) || (defined(HAVE_OS_DARK_MODE_SUPPORT) && HAVE_OS_DARK_MODE_SUPPORT)

/* Information about the Frame on the page. */
class Frame final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        LoaderIdSet = 1 << 1,
        UrlSet = 1 << 2,
        SecurityOriginSet = 1 << 3,
        MimeTypeSet = 1 << 4,
        AllFieldsSet = (IdSet | LoaderIdSet | UrlSet | SecurityOriginSet | MimeTypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Frame*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Frame;
    public:

        Builder<STATE | IdSet>& setId(const String& in_id)
        {
            COMPILE_ASSERT(!(STATE & IdSet), property_id_already_set);
            m_result->setString("id"_s, in_id);
            return castState<IdSet>();
        }

        Builder<STATE | LoaderIdSet>& setLoaderId(const String& in_loaderId)
        {
            COMPILE_ASSERT(!(STATE & LoaderIdSet), property_loaderId_already_set);
            m_result->setString("loaderId"_s, in_loaderId);
            return castState<LoaderIdSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& in_url)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url"_s, in_url);
            return castState<UrlSet>();
        }

        Builder<STATE | SecurityOriginSet>& setSecurityOrigin(const String& in_securityOrigin)
        {
            COMPILE_ASSERT(!(STATE & SecurityOriginSet), property_securityOrigin_already_set);
            m_result->setString("securityOrigin"_s, in_securityOrigin);
            return castState<SecurityOriginSet>();
        }

        Builder<STATE | MimeTypeSet>& setMimeType(const String& in_mimeType)
        {
            COMPILE_ASSERT(!(STATE & MimeTypeSet), property_mimeType_already_set);
            m_result->setString("mimeType"_s, in_mimeType);
            return castState<MimeTypeSet>();
        }

        Ref<Frame> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Frame) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Frame>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Frame> result = Frame::create()
     *     .setId(...)
     *     .setLoaderId(...)
     *     .setUrl(...)
     *     .setSecurityOrigin(...)
     *     .setMimeType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setParentId(const String& in_opt_parentId)
    {
        JSON::ObjectBase::setString("parentId"_s, in_opt_parentId);
    }

    void setName(const String& in_opt_name)
    {
        JSON::ObjectBase::setString("name"_s, in_opt_name);
    }
};

class FrameResource final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        TypeSet = 1 << 1,
        MimeTypeSet = 1 << 2,
        AllFieldsSet = (UrlSet | TypeSet | MimeTypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*FrameResource*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class FrameResource;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& in_url)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url"_s, in_url);
            return castState<UrlSet>();
        }

        Builder<STATE | TypeSet>& setType(Protocol::Page::ResourceType in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Builder<STATE | MimeTypeSet>& setMimeType(const String& in_mimeType)
        {
            COMPILE_ASSERT(!(STATE & MimeTypeSet), property_mimeType_already_set);
            m_result->setString("mimeType"_s, in_mimeType);
            return castState<MimeTypeSet>();
        }

        Ref<FrameResource> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(FrameResource) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<FrameResource>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<FrameResource> result = FrameResource::create()
     *     .setUrl(...)
     *     .setType(...)
     *     .setMimeType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setFailed(bool in_opt_failed)
    {
        JSON::ObjectBase::setBoolean("failed"_s, in_opt_failed);
    }

    void setCanceled(bool in_opt_canceled)
    {
        JSON::ObjectBase::setBoolean("canceled"_s, in_opt_canceled);
    }

    void setSourceMapURL(const String& in_opt_sourceMapURL)
    {
        JSON::ObjectBase::setString("sourceMapURL"_s, in_opt_sourceMapURL);
    }

    void setTargetId(const String& in_opt_targetId)
    {
        JSON::ObjectBase::setString("targetId"_s, in_opt_targetId);
    }
};

/* Information about the Frame hierarchy along with their cached resources. */
class FrameResourceTree final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        FrameSet = 1 << 0,
        ResourcesSet = 1 << 1,
        AllFieldsSet = (FrameSet | ResourcesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*FrameResourceTree*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class FrameResourceTree;
    public:

        Builder<STATE | FrameSet>& setFrame(Ref<Protocol::Page::Frame>&& in_frame)
        {
            COMPILE_ASSERT(!(STATE & FrameSet), property_frame_already_set);
            m_result->setObject("frame"_s, WTFMove(in_frame));
            return castState<FrameSet>();
        }

        Builder<STATE | ResourcesSet>& setResources(Ref<JSON::ArrayOf<Protocol::Page::FrameResource>>&& in_resources)
        {
            COMPILE_ASSERT(!(STATE & ResourcesSet), property_resources_already_set);
            m_result->setArray("resources"_s, WTFMove(in_resources));
            return castState<ResourcesSet>();
        }

        Ref<FrameResourceTree> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(FrameResourceTree) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<FrameResourceTree>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<FrameResourceTree> result = FrameResourceTree::create()
     *     .setFrame(...)
     *     .setResources(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setChildFrames(Ref<JSON::ArrayOf<Protocol::Page::FrameResourceTree>>&& in_opt_childFrames)
    {
        JSON::ObjectBase::setArray("childFrames"_s, WTFMove(in_opt_childFrames));
    }
};

/* Search result for resource. */
class SearchResult final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        FrameIdSet = 1 << 1,
        MatchesCountSet = 1 << 2,
        AllFieldsSet = (UrlSet | FrameIdSet | MatchesCountSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*SearchResult*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class SearchResult;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& in_url)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url"_s, in_url);
            return castState<UrlSet>();
        }

        Builder<STATE | FrameIdSet>& setFrameId(const String& in_frameId)
        {
            COMPILE_ASSERT(!(STATE & FrameIdSet), property_frameId_already_set);
            m_result->setString("frameId"_s, in_frameId);
            return castState<FrameIdSet>();
        }

        Builder<STATE | MatchesCountSet>& setMatchesCount(double in_matchesCount)
        {
            COMPILE_ASSERT(!(STATE & MatchesCountSet), property_matchesCount_already_set);
            m_result->setDouble("matchesCount"_s, in_matchesCount);
            return castState<MatchesCountSet>();
        }

        Ref<SearchResult> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(SearchResult) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<SearchResult>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<SearchResult> result = SearchResult::create()
     *     .setUrl(...)
     *     .setFrameId(...)
     *     .setMatchesCount(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setRequestId(const String& in_opt_requestId)
    {
        JSON::ObjectBase::setString("requestId"_s, in_opt_requestId);
    }
};

/* Cookie object */
class Cookie final : public JSON::Object {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        DomainSet = 1 << 2,
        PathSet = 1 << 3,
        ExpiresSet = 1 << 4,
        SessionSet = 1 << 5,
        HttpOnlySet = 1 << 6,
        SecureSet = 1 << 7,
        SameSiteSet = 1 << 8,
        AllFieldsSet = (NameSet | ValueSet | DomainSet | PathSet | ExpiresSet | SessionSet | HttpOnlySet | SecureSet | SameSiteSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Cookie*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Cookie;
    public:

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& in_value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString("value"_s, in_value);
            return castState<ValueSet>();
        }

        Builder<STATE | DomainSet>& setDomain(const String& in_domain)
        {
            COMPILE_ASSERT(!(STATE & DomainSet), property_domain_already_set);
            m_result->setString("domain"_s, in_domain);
            return castState<DomainSet>();
        }

        Builder<STATE | PathSet>& setPath(const String& in_path)
        {
            COMPILE_ASSERT(!(STATE & PathSet), property_path_already_set);
            m_result->setString("path"_s, in_path);
            return castState<PathSet>();
        }

        Builder<STATE | ExpiresSet>& setExpires(double in_expires)
        {
            COMPILE_ASSERT(!(STATE & ExpiresSet), property_expires_already_set);
            m_result->setDouble("expires"_s, in_expires);
            return castState<ExpiresSet>();
        }

        Builder<STATE | SessionSet>& setSession(bool in_session)
        {
            COMPILE_ASSERT(!(STATE & SessionSet), property_session_already_set);
            m_result->setBoolean("session"_s, in_session);
            return castState<SessionSet>();
        }

        Builder<STATE | HttpOnlySet>& setHttpOnly(bool in_httpOnly)
        {
            COMPILE_ASSERT(!(STATE & HttpOnlySet), property_httpOnly_already_set);
            m_result->setBoolean("httpOnly"_s, in_httpOnly);
            return castState<HttpOnlySet>();
        }

        Builder<STATE | SecureSet>& setSecure(bool in_secure)
        {
            COMPILE_ASSERT(!(STATE & SecureSet), property_secure_already_set);
            m_result->setBoolean("secure"_s, in_secure);
            return castState<SecureSet>();
        }

        Builder<STATE | SameSiteSet>& setSameSite(Protocol::Page::CookieSameSitePolicy in_sameSite)
        {
            COMPILE_ASSERT(!(STATE & SameSiteSet), property_sameSite_already_set);
            m_result->setString("sameSite"_s, Protocol::Helpers::getEnumConstantValue(in_sameSite));
            return castState<SameSiteSet>();
        }

        Ref<Cookie> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Cookie) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Cookie>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Cookie> result = Cookie::create()
     *     .setName(...)
     *     .setValue(...)
     *     .setDomain(...)
     *     .setPath(...)
     *     .setExpires(...)
     *     .setSession(...)
     *     .setHttpOnly(...)
     *     .setSecure(...)
     *     .setSameSite(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* nameKey;
    JS_EXPORT_PRIVATE static const char* valueKey;
    JS_EXPORT_PRIVATE static const char* domainKey;
    JS_EXPORT_PRIVATE static const char* pathKey;
    JS_EXPORT_PRIVATE static const char* expiresKey;
    JS_EXPORT_PRIVATE static const char* sessionKey;
    JS_EXPORT_PRIVATE static const char* httpOnlyKey;
    JS_EXPORT_PRIVATE static const char* secureKey;
    JS_EXPORT_PRIVATE static const char* sameSiteKey;
};

} // Page

namespace Recording {

/* The type of the recording. */
enum class Type {
    Canvas2D = 42,
    CanvasBitmapRenderer = 182,
    CanvasWebGL = 183,
    CanvasWebGL2 = 184,
}; // enum class Type

enum class Initiator {
    Frontend = 185,
    Console = 186,
    AutoCapture = 187,
}; // enum class Initiator

/* Information about the initial state of the recorded object. */
class InitialState final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*InitialState*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class InitialState;
    public:

        Ref<InitialState> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(InitialState) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<InitialState>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<InitialState> result = InitialState::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setAttributes(Ref<JSON::Object>&& in_opt_attributes)
    {
        JSON::ObjectBase::setObject("attributes"_s, WTFMove(in_opt_attributes));
    }

    void setStates(Ref<JSON::ArrayOf<JSON::Object>>&& in_opt_states)
    {
        JSON::ObjectBase::setArray("states"_s, WTFMove(in_opt_states));
    }

    void setParameters(Ref<JSON::ArrayOf<JSON::Value>>&& in_opt_parameters)
    {
        JSON::ObjectBase::setArray("parameters"_s, WTFMove(in_opt_parameters));
    }

    void setContent(const String& in_opt_content)
    {
        JSON::ObjectBase::setString("content"_s, in_opt_content);
    }
};

/* Container object for a single frame of the recording. */
class Frame final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ActionsSet = 1 << 0,
        AllFieldsSet = (ActionsSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Frame*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Frame;
    public:

        Builder<STATE | ActionsSet>& setActions(Ref<JSON::ArrayOf<JSON::Value>>&& in_actions)
        {
            COMPILE_ASSERT(!(STATE & ActionsSet), property_actions_already_set);
            m_result->setArray("actions"_s, WTFMove(in_actions));
            return castState<ActionsSet>();
        }

        Ref<Frame> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Frame) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Frame>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Frame> result = Frame::create()
     *     .setActions(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setDuration(double in_opt_duration)
    {
        JSON::ObjectBase::setDouble("duration"_s, in_opt_duration);
    }

    void setIncomplete(bool in_opt_incomplete)
    {
        JSON::ObjectBase::setBoolean("incomplete"_s, in_opt_incomplete);
    }
};

class Recording final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        VersionSet = 1 << 0,
        TypeSet = 1 << 1,
        InitialStateSet = 1 << 2,
        DataSet = 1 << 3,
        AllFieldsSet = (VersionSet | TypeSet | InitialStateSet | DataSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Recording*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Recording;
    public:

        Builder<STATE | VersionSet>& setVersion(int in_version)
        {
            COMPILE_ASSERT(!(STATE & VersionSet), property_version_already_set);
            m_result->setInteger("version"_s, in_version);
            return castState<VersionSet>();
        }

        Builder<STATE | TypeSet>& setType(Protocol::Recording::Type in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Builder<STATE | InitialStateSet>& setInitialState(Ref<Protocol::Recording::InitialState>&& in_initialState)
        {
            COMPILE_ASSERT(!(STATE & InitialStateSet), property_initialState_already_set);
            m_result->setObject("initialState"_s, WTFMove(in_initialState));
            return castState<InitialStateSet>();
        }

        Builder<STATE | DataSet>& setData(Ref<JSON::ArrayOf<JSON::Value>>&& in_data)
        {
            COMPILE_ASSERT(!(STATE & DataSet), property_data_already_set);
            m_result->setArray("data"_s, WTFMove(in_data));
            return castState<DataSet>();
        }

        Ref<Recording> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Recording) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Recording>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Recording> result = Recording::create()
     *     .setVersion(...)
     *     .setType(...)
     *     .setInitialState(...)
     *     .setData(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setName(const String& in_opt_name)
    {
        JSON::ObjectBase::setString("name"_s, in_opt_name);
    }
};

} // Recording

namespace Runtime {

/* Mirror object referencing original JavaScript object. */
class RemoteObject final : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating RemoteObject.
    enum class Type {
        Object = 188,
        Function = 189,
        Undefined = 190,
        String = 129,
        Number = 128,
        Boolean = 191,
        Symbol = 192,
        Bigint = 193,
    }; // enum class Type

    // Named after property name 'subtype' while generating RemoteObject.
    enum class Subtype {
        Array = 130,
        Null = 131,
        Node = 194,
        Regexp = 195,
        Date = 103,
        Error = 73,
        Map = 196,
        Set = 197,
        Weakmap = 198,
        Weakset = 199,
        Iterator = 200,
        Class = 201,
        Proxy = 202,
    }; // enum class Subtype

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*RemoteObject*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class RemoteObject;
    public:

        Builder<STATE | TypeSet>& setType(Type in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Ref<RemoteObject> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(RemoteObject) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<RemoteObject>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<RemoteObject> result = RemoteObject::create()
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setSubtype(Subtype in_opt_subtype)
    {
        JSON::ObjectBase::setString("subtype"_s, Protocol::Helpers::getEnumConstantValue(in_opt_subtype));
    }

    void setClassName(const String& in_opt_className)
    {
        JSON::ObjectBase::setString("className"_s, in_opt_className);
    }

    void setValue(Ref<JSON::Value>&& in_opt_value)
    {
        JSON::ObjectBase::setValue("value"_s, WTFMove(in_opt_value));
    }

    void setDescription(const String& in_opt_description)
    {
        JSON::ObjectBase::setString("description"_s, in_opt_description);
    }

    void setObjectId(const String& in_opt_objectId)
    {
        JSON::ObjectBase::setString("objectId"_s, in_opt_objectId);
    }

    void setSize(int in_opt_size)
    {
        JSON::ObjectBase::setInteger("size"_s, in_opt_size);
    }

    void setClassPrototype(Ref<Protocol::Runtime::RemoteObject>&& in_opt_classPrototype)
    {
        JSON::ObjectBase::setObject("classPrototype"_s, WTFMove(in_opt_classPrototype));
    }

    void setPreview(Ref<Protocol::Runtime::ObjectPreview>&& in_opt_preview)
    {
        JSON::ObjectBase::setObject("preview"_s, WTFMove(in_opt_preview));
    }
};

/* Object containing abbreviated remote object value. */
class ObjectPreview final : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating ObjectPreview.
    enum class Type {
        Object = 188,
        Function = 189,
        Undefined = 190,
        String = 129,
        Number = 128,
        Boolean = 191,
        Symbol = 192,
        Bigint = 193,
    }; // enum class Type

    // Named after property name 'subtype' while generating ObjectPreview.
    enum class Subtype {
        Array = 130,
        Null = 131,
        Node = 194,
        Regexp = 195,
        Date = 103,
        Error = 73,
        Map = 196,
        Set = 197,
        Weakmap = 198,
        Weakset = 199,
        Iterator = 200,
        Class = 201,
        Proxy = 202,
    }; // enum class Subtype

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        LosslessSet = 1 << 1,
        AllFieldsSet = (TypeSet | LosslessSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ObjectPreview*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ObjectPreview;
    public:

        Builder<STATE | TypeSet>& setType(Type in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Builder<STATE | LosslessSet>& setLossless(bool in_lossless)
        {
            COMPILE_ASSERT(!(STATE & LosslessSet), property_lossless_already_set);
            m_result->setBoolean("lossless"_s, in_lossless);
            return castState<LosslessSet>();
        }

        Ref<ObjectPreview> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ObjectPreview) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<ObjectPreview>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ObjectPreview> result = ObjectPreview::create()
     *     .setType(...)
     *     .setLossless(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setSubtype(Subtype in_opt_subtype)
    {
        JSON::ObjectBase::setString("subtype"_s, Protocol::Helpers::getEnumConstantValue(in_opt_subtype));
    }

    void setDescription(const String& in_opt_description)
    {
        JSON::ObjectBase::setString("description"_s, in_opt_description);
    }

    void setOverflow(bool in_opt_overflow)
    {
        JSON::ObjectBase::setBoolean("overflow"_s, in_opt_overflow);
    }

    void setProperties(Ref<JSON::ArrayOf<Protocol::Runtime::PropertyPreview>>&& in_opt_properties)
    {
        JSON::ObjectBase::setArray("properties"_s, WTFMove(in_opt_properties));
    }

    void setEntries(Ref<JSON::ArrayOf<Protocol::Runtime::EntryPreview>>&& in_opt_entries)
    {
        JSON::ObjectBase::setArray("entries"_s, WTFMove(in_opt_entries));
    }

    void setSize(int in_opt_size)
    {
        JSON::ObjectBase::setInteger("size"_s, in_opt_size);
    }
};

class PropertyPreview final : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating PropertyPreview.
    enum class Type {
        Object = 188,
        Function = 189,
        Undefined = 190,
        String = 129,
        Number = 128,
        Boolean = 191,
        Symbol = 192,
        Bigint = 193,
        Accessor = 203,
    }; // enum class Type

    // Named after property name 'subtype' while generating PropertyPreview.
    enum class Subtype {
        Array = 130,
        Null = 131,
        Node = 194,
        Regexp = 195,
        Date = 103,
        Error = 73,
        Map = 196,
        Set = 197,
        Weakmap = 198,
        Weakset = 199,
        Iterator = 200,
        Class = 201,
        Proxy = 202,
    }; // enum class Subtype

    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        TypeSet = 1 << 1,
        AllFieldsSet = (NameSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*PropertyPreview*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class PropertyPreview;
    public:

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Builder<STATE | TypeSet>& setType(Type in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Ref<PropertyPreview> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(PropertyPreview) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<PropertyPreview>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<PropertyPreview> result = PropertyPreview::create()
     *     .setName(...)
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setSubtype(Subtype in_opt_subtype)
    {
        JSON::ObjectBase::setString("subtype"_s, Protocol::Helpers::getEnumConstantValue(in_opt_subtype));
    }

    void setValue(const String& in_opt_value)
    {
        JSON::ObjectBase::setString("value"_s, in_opt_value);
    }

    void setValuePreview(Ref<Protocol::Runtime::ObjectPreview>&& in_opt_valuePreview)
    {
        JSON::ObjectBase::setObject("valuePreview"_s, WTFMove(in_opt_valuePreview));
    }

    void setInternal(bool in_opt_internal)
    {
        JSON::ObjectBase::setBoolean("internal"_s, in_opt_internal);
    }
};

class EntryPreview final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ValueSet = 1 << 0,
        AllFieldsSet = (ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*EntryPreview*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class EntryPreview;
    public:

        Builder<STATE | ValueSet>& setValue(Ref<Protocol::Runtime::ObjectPreview>&& in_value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setObject("value"_s, WTFMove(in_value));
            return castState<ValueSet>();
        }

        Ref<EntryPreview> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(EntryPreview) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<EntryPreview>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<EntryPreview> result = EntryPreview::create()
     *     .setValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setKey(Ref<Protocol::Runtime::ObjectPreview>&& in_opt_key)
    {
        JSON::ObjectBase::setObject("key"_s, WTFMove(in_opt_key));
    }
};

class CollectionEntry final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ValueSet = 1 << 0,
        AllFieldsSet = (ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CollectionEntry*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CollectionEntry;
    public:

        Builder<STATE | ValueSet>& setValue(Ref<Protocol::Runtime::RemoteObject>&& in_value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setObject("value"_s, WTFMove(in_value));
            return castState<ValueSet>();
        }

        Ref<CollectionEntry> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CollectionEntry) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CollectionEntry>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CollectionEntry> result = CollectionEntry::create()
     *     .setValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setKey(Ref<Protocol::Runtime::RemoteObject>&& in_opt_key)
    {
        JSON::ObjectBase::setObject("key"_s, WTFMove(in_opt_key));
    }
};

/* Object property descriptor. */
class PropertyDescriptor final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        AllFieldsSet = (NameSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*PropertyDescriptor*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class PropertyDescriptor;
    public:

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Ref<PropertyDescriptor> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(PropertyDescriptor) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<PropertyDescriptor>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<PropertyDescriptor> result = PropertyDescriptor::create()
     *     .setName(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setValue(Ref<Protocol::Runtime::RemoteObject>&& in_opt_value)
    {
        JSON::ObjectBase::setObject("value"_s, WTFMove(in_opt_value));
    }

    void setWritable(bool in_opt_writable)
    {
        JSON::ObjectBase::setBoolean("writable"_s, in_opt_writable);
    }

    void setGet(Ref<Protocol::Runtime::RemoteObject>&& in_opt_get)
    {
        JSON::ObjectBase::setObject("get"_s, WTFMove(in_opt_get));
    }

    void setSet(Ref<Protocol::Runtime::RemoteObject>&& in_opt_set)
    {
        JSON::ObjectBase::setObject("set"_s, WTFMove(in_opt_set));
    }

    void setWasThrown(bool in_opt_wasThrown)
    {
        JSON::ObjectBase::setBoolean("wasThrown"_s, in_opt_wasThrown);
    }

    void setConfigurable(bool in_opt_configurable)
    {
        JSON::ObjectBase::setBoolean("configurable"_s, in_opt_configurable);
    }

    void setEnumerable(bool in_opt_enumerable)
    {
        JSON::ObjectBase::setBoolean("enumerable"_s, in_opt_enumerable);
    }

    void setIsOwn(bool in_opt_isOwn)
    {
        JSON::ObjectBase::setBoolean("isOwn"_s, in_opt_isOwn);
    }

    void setSymbol(Ref<Protocol::Runtime::RemoteObject>&& in_opt_symbol)
    {
        JSON::ObjectBase::setObject("symbol"_s, WTFMove(in_opt_symbol));
    }

    void setNativeGetter(bool in_opt_nativeGetter)
    {
        JSON::ObjectBase::setBoolean("nativeGetter"_s, in_opt_nativeGetter);
    }
};

/* Object internal property descriptor. This property isn't normally visible in JavaScript code. */
class InternalPropertyDescriptor final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        AllFieldsSet = (NameSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*InternalPropertyDescriptor*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class InternalPropertyDescriptor;
    public:

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Ref<InternalPropertyDescriptor> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(InternalPropertyDescriptor) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<InternalPropertyDescriptor>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<InternalPropertyDescriptor> result = InternalPropertyDescriptor::create()
     *     .setName(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setValue(Ref<Protocol::Runtime::RemoteObject>&& in_opt_value)
    {
        JSON::ObjectBase::setObject("value"_s, WTFMove(in_opt_value));
    }
};

/* Represents function call argument. Either remote object id <code>objectId</code> or primitive <code>value</code> or neither of (for undefined) them should be specified. */
class CallArgument final : public JSON::Object {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CallArgument*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CallArgument;
    public:

        Ref<CallArgument> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CallArgument) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CallArgument>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CallArgument> result = CallArgument::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setValue(Ref<JSON::Value>&& in_opt_value)
    {
        JSON::ObjectBase::setValue("value"_s, WTFMove(in_opt_value));
    }

    void setObjectId(const String& in_opt_objectId)
    {
        JSON::ObjectBase::setString("objectId"_s, in_opt_objectId);
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* objectIdKey;
};

/* Type of the execution context. */
enum class ExecutionContextType {
    Normal = 5,
    User = 16,
    Internal = 204,
}; // enum class ExecutionContextType

/* Description of an isolated world. */
class ExecutionContextDescription final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        TypeSet = 1 << 1,
        NameSet = 1 << 2,
        FrameIdSet = 1 << 3,
        AllFieldsSet = (IdSet | TypeSet | NameSet | FrameIdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ExecutionContextDescription*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ExecutionContextDescription;
    public:

        Builder<STATE | IdSet>& setId(int in_id)
        {
            COMPILE_ASSERT(!(STATE & IdSet), property_id_already_set);
            m_result->setInteger("id"_s, in_id);
            return castState<IdSet>();
        }

        Builder<STATE | TypeSet>& setType(Protocol::Runtime::ExecutionContextType in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Builder<STATE | FrameIdSet>& setFrameId(const String& in_frameId)
        {
            COMPILE_ASSERT(!(STATE & FrameIdSet), property_frameId_already_set);
            m_result->setString("frameId"_s, in_frameId);
            return castState<FrameIdSet>();
        }

        Ref<ExecutionContextDescription> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ExecutionContextDescription) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<ExecutionContextDescription>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ExecutionContextDescription> result = ExecutionContextDescription::create()
     *     .setId(...)
     *     .setType(...)
     *     .setName(...)
     *     .setFrameId(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Syntax error type: "none" for no error, "irrecoverable" for unrecoverable errors, "unterminated-literal" for when there is an unterminated literal, "recoverable" for when the expression is unfinished but valid so far. */
enum class SyntaxErrorType {
    None = 9,
    Irrecoverable = 205,
    UnterminatedLiteral = 206,
    Recoverable = 207,
}; // enum class SyntaxErrorType

/* Range of an error in source code. */
class ErrorRange final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StartOffsetSet = 1 << 0,
        EndOffsetSet = 1 << 1,
        AllFieldsSet = (StartOffsetSet | EndOffsetSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ErrorRange*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ErrorRange;
    public:

        Builder<STATE | StartOffsetSet>& setStartOffset(int in_startOffset)
        {
            COMPILE_ASSERT(!(STATE & StartOffsetSet), property_startOffset_already_set);
            m_result->setInteger("startOffset"_s, in_startOffset);
            return castState<StartOffsetSet>();
        }

        Builder<STATE | EndOffsetSet>& setEndOffset(int in_endOffset)
        {
            COMPILE_ASSERT(!(STATE & EndOffsetSet), property_endOffset_already_set);
            m_result->setInteger("endOffset"_s, in_endOffset);
            return castState<EndOffsetSet>();
        }

        Ref<ErrorRange> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ErrorRange) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<ErrorRange>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ErrorRange> result = ErrorRange::create()
     *     .setStartOffset(...)
     *     .setEndOffset(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

class StructureDescription final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*StructureDescription*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class StructureDescription;
    public:

        Ref<StructureDescription> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(StructureDescription) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<StructureDescription>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<StructureDescription> result = StructureDescription::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setFields(Ref<JSON::ArrayOf<String>>&& in_opt_fields)
    {
        JSON::ObjectBase::setArray("fields"_s, WTFMove(in_opt_fields));
    }

    void setOptionalFields(Ref<JSON::ArrayOf<String>>&& in_opt_optionalFields)
    {
        JSON::ObjectBase::setArray("optionalFields"_s, WTFMove(in_opt_optionalFields));
    }

    void setConstructorName(const String& in_opt_constructorName)
    {
        JSON::ObjectBase::setString("constructorName"_s, in_opt_constructorName);
    }

    void setPrototypeStructure(Ref<Protocol::Runtime::StructureDescription>&& in_opt_prototypeStructure)
    {
        JSON::ObjectBase::setObject("prototypeStructure"_s, WTFMove(in_opt_prototypeStructure));
    }

    void setIsImprecise(bool in_opt_isImprecise)
    {
        JSON::ObjectBase::setBoolean("isImprecise"_s, in_opt_isImprecise);
    }
};

class TypeSet final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IsFunctionSet = 1 << 0,
        IsUndefinedSet = 1 << 1,
        IsNullSet = 1 << 2,
        IsBooleanSet = 1 << 3,
        IsIntegerSet = 1 << 4,
        IsNumberSet = 1 << 5,
        IsStringSet = 1 << 6,
        IsObjectSet = 1 << 7,
        IsSymbolSet = 1 << 8,
        IsBigIntSet = 1 << 9,
        AllFieldsSet = (IsFunctionSet | IsUndefinedSet | IsNullSet | IsBooleanSet | IsIntegerSet | IsNumberSet | IsStringSet | IsObjectSet | IsSymbolSet | IsBigIntSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*TypeSet*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class TypeSet;
    public:

        Builder<STATE | IsFunctionSet>& setIsFunction(bool in_isFunction)
        {
            COMPILE_ASSERT(!(STATE & IsFunctionSet), property_isFunction_already_set);
            m_result->setBoolean("isFunction"_s, in_isFunction);
            return castState<IsFunctionSet>();
        }

        Builder<STATE | IsUndefinedSet>& setIsUndefined(bool in_isUndefined)
        {
            COMPILE_ASSERT(!(STATE & IsUndefinedSet), property_isUndefined_already_set);
            m_result->setBoolean("isUndefined"_s, in_isUndefined);
            return castState<IsUndefinedSet>();
        }

        Builder<STATE | IsNullSet>& setIsNull(bool in_isNull)
        {
            COMPILE_ASSERT(!(STATE & IsNullSet), property_isNull_already_set);
            m_result->setBoolean("isNull"_s, in_isNull);
            return castState<IsNullSet>();
        }

        Builder<STATE | IsBooleanSet>& setIsBoolean(bool in_isBoolean)
        {
            COMPILE_ASSERT(!(STATE & IsBooleanSet), property_isBoolean_already_set);
            m_result->setBoolean("isBoolean"_s, in_isBoolean);
            return castState<IsBooleanSet>();
        }

        Builder<STATE | IsIntegerSet>& setIsInteger(bool in_isInteger)
        {
            COMPILE_ASSERT(!(STATE & IsIntegerSet), property_isInteger_already_set);
            m_result->setBoolean("isInteger"_s, in_isInteger);
            return castState<IsIntegerSet>();
        }

        Builder<STATE | IsNumberSet>& setIsNumber(bool in_isNumber)
        {
            COMPILE_ASSERT(!(STATE & IsNumberSet), property_isNumber_already_set);
            m_result->setBoolean("isNumber"_s, in_isNumber);
            return castState<IsNumberSet>();
        }

        Builder<STATE | IsStringSet>& setIsString(bool in_isString)
        {
            COMPILE_ASSERT(!(STATE & IsStringSet), property_isString_already_set);
            m_result->setBoolean("isString"_s, in_isString);
            return castState<IsStringSet>();
        }

        Builder<STATE | IsObjectSet>& setIsObject(bool in_isObject)
        {
            COMPILE_ASSERT(!(STATE & IsObjectSet), property_isObject_already_set);
            m_result->setBoolean("isObject"_s, in_isObject);
            return castState<IsObjectSet>();
        }

        Builder<STATE | IsSymbolSet>& setIsSymbol(bool in_isSymbol)
        {
            COMPILE_ASSERT(!(STATE & IsSymbolSet), property_isSymbol_already_set);
            m_result->setBoolean("isSymbol"_s, in_isSymbol);
            return castState<IsSymbolSet>();
        }

        Builder<STATE | IsBigIntSet>& setIsBigInt(bool in_isBigInt)
        {
            COMPILE_ASSERT(!(STATE & IsBigIntSet), property_isBigInt_already_set);
            m_result->setBoolean("isBigInt"_s, in_isBigInt);
            return castState<IsBigIntSet>();
        }

        Ref<TypeSet> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(TypeSet) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<TypeSet>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<TypeSet> result = TypeSet::create()
     *     .setIsFunction(...)
     *     .setIsUndefined(...)
     *     .setIsNull(...)
     *     .setIsBoolean(...)
     *     .setIsInteger(...)
     *     .setIsNumber(...)
     *     .setIsString(...)
     *     .setIsObject(...)
     *     .setIsSymbol(...)
     *     .setIsBigInt(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Container for type information that has been gathered. */
class TypeDescription final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IsValidSet = 1 << 0,
        AllFieldsSet = (IsValidSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*TypeDescription*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class TypeDescription;
    public:

        Builder<STATE | IsValidSet>& setIsValid(bool in_isValid)
        {
            COMPILE_ASSERT(!(STATE & IsValidSet), property_isValid_already_set);
            m_result->setBoolean("isValid"_s, in_isValid);
            return castState<IsValidSet>();
        }

        Ref<TypeDescription> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(TypeDescription) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<TypeDescription>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<TypeDescription> result = TypeDescription::create()
     *     .setIsValid(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setLeastCommonAncestor(const String& in_opt_leastCommonAncestor)
    {
        JSON::ObjectBase::setString("leastCommonAncestor"_s, in_opt_leastCommonAncestor);
    }

    void setTypeSet(Ref<Protocol::Runtime::TypeSet>&& in_opt_typeSet)
    {
        JSON::ObjectBase::setObject("typeSet"_s, WTFMove(in_opt_typeSet));
    }

    void setStructures(Ref<JSON::ArrayOf<Protocol::Runtime::StructureDescription>>&& in_opt_structures)
    {
        JSON::ObjectBase::setArray("structures"_s, WTFMove(in_opt_structures));
    }

    void setIsTruncated(bool in_opt_isTruncated)
    {
        JSON::ObjectBase::setBoolean("isTruncated"_s, in_opt_isTruncated);
    }
};

/* Describes the location of an expression we want type information for. */
class TypeLocation final : public JSON::Object {
public:
    enum {
        NoFieldsSet = 0,
        TypeInformationDescriptorSet = 1 << 0,
        SourceIDSet = 1 << 1,
        DivotSet = 1 << 2,
        AllFieldsSet = (TypeInformationDescriptorSet | SourceIDSet | DivotSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*TypeLocation*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class TypeLocation;
    public:

        Builder<STATE | TypeInformationDescriptorSet>& setTypeInformationDescriptor(int in_typeInformationDescriptor)
        {
            COMPILE_ASSERT(!(STATE & TypeInformationDescriptorSet), property_typeInformationDescriptor_already_set);
            m_result->setInteger("typeInformationDescriptor"_s, in_typeInformationDescriptor);
            return castState<TypeInformationDescriptorSet>();
        }

        Builder<STATE | SourceIDSet>& setSourceID(const String& in_sourceID)
        {
            COMPILE_ASSERT(!(STATE & SourceIDSet), property_sourceID_already_set);
            m_result->setString("sourceID"_s, in_sourceID);
            return castState<SourceIDSet>();
        }

        Builder<STATE | DivotSet>& setDivot(int in_divot)
        {
            COMPILE_ASSERT(!(STATE & DivotSet), property_divot_already_set);
            m_result->setInteger("divot"_s, in_divot);
            return castState<DivotSet>();
        }

        Ref<TypeLocation> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(TypeLocation) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<TypeLocation>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<TypeLocation> result = TypeLocation::create()
     *     .setTypeInformationDescriptor(...)
     *     .setSourceID(...)
     *     .setDivot(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* typeInformationDescriptorKey;
    JS_EXPORT_PRIVATE static const char* sourceIDKey;
    JS_EXPORT_PRIVATE static const char* divotKey;
};

/* From Wikipedia: a basic block is a portion of the code within a program with only one entry point and only one exit point. This type gives the location of a basic block and if that basic block has executed. */
class BasicBlock final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StartOffsetSet = 1 << 0,
        EndOffsetSet = 1 << 1,
        HasExecutedSet = 1 << 2,
        ExecutionCountSet = 1 << 3,
        AllFieldsSet = (StartOffsetSet | EndOffsetSet | HasExecutedSet | ExecutionCountSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*BasicBlock*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class BasicBlock;
    public:

        Builder<STATE | StartOffsetSet>& setStartOffset(int in_startOffset)
        {
            COMPILE_ASSERT(!(STATE & StartOffsetSet), property_startOffset_already_set);
            m_result->setInteger("startOffset"_s, in_startOffset);
            return castState<StartOffsetSet>();
        }

        Builder<STATE | EndOffsetSet>& setEndOffset(int in_endOffset)
        {
            COMPILE_ASSERT(!(STATE & EndOffsetSet), property_endOffset_already_set);
            m_result->setInteger("endOffset"_s, in_endOffset);
            return castState<EndOffsetSet>();
        }

        Builder<STATE | HasExecutedSet>& setHasExecuted(bool in_hasExecuted)
        {
            COMPILE_ASSERT(!(STATE & HasExecutedSet), property_hasExecuted_already_set);
            m_result->setBoolean("hasExecuted"_s, in_hasExecuted);
            return castState<HasExecutedSet>();
        }

        Builder<STATE | ExecutionCountSet>& setExecutionCount(int in_executionCount)
        {
            COMPILE_ASSERT(!(STATE & ExecutionCountSet), property_executionCount_already_set);
            m_result->setInteger("executionCount"_s, in_executionCount);
            return castState<ExecutionCountSet>();
        }

        Ref<BasicBlock> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(BasicBlock) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<BasicBlock>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<BasicBlock> result = BasicBlock::create()
     *     .setStartOffset(...)
     *     .setEndOffset(...)
     *     .setHasExecuted(...)
     *     .setExecutionCount(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // Runtime

namespace ScriptProfiler {

enum class EventType {
    API = 208,
    Microtask = 209,
    Other = 153,
}; // enum class EventType

class Event final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StartTimeSet = 1 << 0,
        EndTimeSet = 1 << 1,
        TypeSet = 1 << 2,
        AllFieldsSet = (StartTimeSet | EndTimeSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Event*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Event;
    public:

        Builder<STATE | StartTimeSet>& setStartTime(double in_startTime)
        {
            COMPILE_ASSERT(!(STATE & StartTimeSet), property_startTime_already_set);
            m_result->setDouble("startTime"_s, in_startTime);
            return castState<StartTimeSet>();
        }

        Builder<STATE | EndTimeSet>& setEndTime(double in_endTime)
        {
            COMPILE_ASSERT(!(STATE & EndTimeSet), property_endTime_already_set);
            m_result->setDouble("endTime"_s, in_endTime);
            return castState<EndTimeSet>();
        }

        Builder<STATE | TypeSet>& setType(Protocol::ScriptProfiler::EventType in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Ref<Event> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Event) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Event>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Event> result = Event::create()
     *     .setStartTime(...)
     *     .setEndTime(...)
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

class ExpressionLocation final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LineSet = 1 << 0,
        ColumnSet = 1 << 1,
        AllFieldsSet = (LineSet | ColumnSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ExpressionLocation*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ExpressionLocation;
    public:

        Builder<STATE | LineSet>& setLine(int in_line)
        {
            COMPILE_ASSERT(!(STATE & LineSet), property_line_already_set);
            m_result->setInteger("line"_s, in_line);
            return castState<LineSet>();
        }

        Builder<STATE | ColumnSet>& setColumn(int in_column)
        {
            COMPILE_ASSERT(!(STATE & ColumnSet), property_column_already_set);
            m_result->setInteger("column"_s, in_column);
            return castState<ColumnSet>();
        }

        Ref<ExpressionLocation> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ExpressionLocation) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<ExpressionLocation>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ExpressionLocation> result = ExpressionLocation::create()
     *     .setLine(...)
     *     .setColumn(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

class StackFrame final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SourceIDSet = 1 << 0,
        NameSet = 1 << 1,
        LineSet = 1 << 2,
        ColumnSet = 1 << 3,
        UrlSet = 1 << 4,
        AllFieldsSet = (SourceIDSet | NameSet | LineSet | ColumnSet | UrlSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*StackFrame*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class StackFrame;
    public:

        Builder<STATE | SourceIDSet>& setSourceID(const String& in_sourceID)
        {
            COMPILE_ASSERT(!(STATE & SourceIDSet), property_sourceID_already_set);
            m_result->setString("sourceID"_s, in_sourceID);
            return castState<SourceIDSet>();
        }

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Builder<STATE | LineSet>& setLine(int in_line)
        {
            COMPILE_ASSERT(!(STATE & LineSet), property_line_already_set);
            m_result->setInteger("line"_s, in_line);
            return castState<LineSet>();
        }

        Builder<STATE | ColumnSet>& setColumn(int in_column)
        {
            COMPILE_ASSERT(!(STATE & ColumnSet), property_column_already_set);
            m_result->setInteger("column"_s, in_column);
            return castState<ColumnSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& in_url)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url"_s, in_url);
            return castState<UrlSet>();
        }

        Ref<StackFrame> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(StackFrame) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<StackFrame>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<StackFrame> result = StackFrame::create()
     *     .setSourceID(...)
     *     .setName(...)
     *     .setLine(...)
     *     .setColumn(...)
     *     .setUrl(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setExpressionLocation(Ref<Protocol::ScriptProfiler::ExpressionLocation>&& in_opt_expressionLocation)
    {
        JSON::ObjectBase::setObject("expressionLocation"_s, WTFMove(in_opt_expressionLocation));
    }
};

class StackTrace final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TimestampSet = 1 << 0,
        StackFramesSet = 1 << 1,
        AllFieldsSet = (TimestampSet | StackFramesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*StackTrace*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class StackTrace;
    public:

        Builder<STATE | TimestampSet>& setTimestamp(double in_timestamp)
        {
            COMPILE_ASSERT(!(STATE & TimestampSet), property_timestamp_already_set);
            m_result->setDouble("timestamp"_s, in_timestamp);
            return castState<TimestampSet>();
        }

        Builder<STATE | StackFramesSet>& setStackFrames(Ref<JSON::ArrayOf<Protocol::ScriptProfiler::StackFrame>>&& in_stackFrames)
        {
            COMPILE_ASSERT(!(STATE & StackFramesSet), property_stackFrames_already_set);
            m_result->setArray("stackFrames"_s, WTFMove(in_stackFrames));
            return castState<StackFramesSet>();
        }

        Ref<StackTrace> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(StackTrace) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<StackTrace>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<StackTrace> result = StackTrace::create()
     *     .setTimestamp(...)
     *     .setStackFrames(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

class Samples final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StackTracesSet = 1 << 0,
        AllFieldsSet = (StackTracesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Samples*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Samples;
    public:

        Builder<STATE | StackTracesSet>& setStackTraces(Ref<JSON::ArrayOf<Protocol::ScriptProfiler::StackTrace>>&& in_stackTraces)
        {
            COMPILE_ASSERT(!(STATE & StackTracesSet), property_stackTraces_already_set);
            m_result->setArray("stackTraces"_s, WTFMove(in_stackTraces));
            return castState<StackTracesSet>();
        }

        Ref<Samples> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Samples) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Samples>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Samples> result = Samples::create()
     *     .setStackTraces(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // ScriptProfiler

namespace Security {

/* Information about a SSL connection to display in the frontend. */
class Connection final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Connection*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Connection;
    public:

        Ref<Connection> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Connection) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Connection>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Connection> result = Connection::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setProtocol(const String& in_opt_protocol)
    {
        JSON::ObjectBase::setString("protocol"_s, in_opt_protocol);
    }

    void setCipher(const String& in_opt_cipher)
    {
        JSON::ObjectBase::setString("cipher"_s, in_opt_cipher);
    }
};

/* Information about a SSL certificate to display in the frontend. */
class Certificate final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Certificate*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Certificate;
    public:

        Ref<Certificate> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Certificate) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Certificate>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Certificate> result = Certificate::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setSubject(const String& in_opt_subject)
    {
        JSON::ObjectBase::setString("subject"_s, in_opt_subject);
    }

    void setValidFrom(double in_opt_validFrom)
    {
        JSON::ObjectBase::setDouble("validFrom"_s, in_opt_validFrom);
    }

    void setValidUntil(double in_opt_validUntil)
    {
        JSON::ObjectBase::setDouble("validUntil"_s, in_opt_validUntil);
    }

    void setDnsNames(Ref<JSON::ArrayOf<String>>&& in_opt_dnsNames)
    {
        JSON::ObjectBase::setArray("dnsNames"_s, WTFMove(in_opt_dnsNames));
    }

    void setIpAddresses(Ref<JSON::ArrayOf<String>>&& in_opt_ipAddresses)
    {
        JSON::ObjectBase::setArray("ipAddresses"_s, WTFMove(in_opt_ipAddresses));
    }
};

/* Security information for a given Network.Response. */
class Security final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Security*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Security;
    public:

        Ref<Security> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Security) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Security>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Security> result = Security::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setConnection(Ref<Protocol::Security::Connection>&& in_opt_connection)
    {
        JSON::ObjectBase::setObject("connection"_s, WTFMove(in_opt_connection));
    }

    void setCertificate(Ref<Protocol::Security::Certificate>&& in_opt_certificate)
    {
        JSON::ObjectBase::setObject("certificate"_s, WTFMove(in_opt_certificate));
    }
};

} // Security

#if defined(ENABLE_SERVICE_WORKER) && ENABLE_SERVICE_WORKER
namespace ServiceWorker {

/* ServiceWorker metadata and initial state. */
class Configuration final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TargetIdSet = 1 << 0,
        SecurityOriginSet = 1 << 1,
        UrlSet = 1 << 2,
        ContentSet = 1 << 3,
        AllFieldsSet = (TargetIdSet | SecurityOriginSet | UrlSet | ContentSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Configuration*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Configuration;
    public:

        Builder<STATE | TargetIdSet>& setTargetId(const String& in_targetId)
        {
            COMPILE_ASSERT(!(STATE & TargetIdSet), property_targetId_already_set);
            m_result->setString("targetId"_s, in_targetId);
            return castState<TargetIdSet>();
        }

        Builder<STATE | SecurityOriginSet>& setSecurityOrigin(const String& in_securityOrigin)
        {
            COMPILE_ASSERT(!(STATE & SecurityOriginSet), property_securityOrigin_already_set);
            m_result->setString("securityOrigin"_s, in_securityOrigin);
            return castState<SecurityOriginSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& in_url)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url"_s, in_url);
            return castState<UrlSet>();
        }

        Builder<STATE | ContentSet>& setContent(const String& in_content)
        {
            COMPILE_ASSERT(!(STATE & ContentSet), property_content_already_set);
            m_result->setString("content"_s, in_content);
            return castState<ContentSet>();
        }

        Ref<Configuration> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Configuration) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Configuration>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Configuration> result = Configuration::create()
     *     .setTargetId(...)
     *     .setSecurityOrigin(...)
     *     .setUrl(...)
     *     .setContent(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // ServiceWorker
#endif // defined(ENABLE_SERVICE_WORKER) && ENABLE_SERVICE_WORKER

namespace Target {

/* Description of a target. */
class TargetInfo final : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating TargetInfo.
    enum class Type {
        Page = 100,
        ServiceWorker = 138,
        Worker = 210,
    }; // enum class Type

    enum {
        NoFieldsSet = 0,
        TargetIdSet = 1 << 0,
        TypeSet = 1 << 1,
        AllFieldsSet = (TargetIdSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*TargetInfo*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class TargetInfo;
    public:

        Builder<STATE | TargetIdSet>& setTargetId(const String& in_targetId)
        {
            COMPILE_ASSERT(!(STATE & TargetIdSet), property_targetId_already_set);
            m_result->setString("targetId"_s, in_targetId);
            return castState<TargetIdSet>();
        }

        Builder<STATE | TypeSet>& setType(Type in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Ref<TargetInfo> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(TargetInfo) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<TargetInfo>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<TargetInfo> result = TargetInfo::create()
     *     .setTargetId(...)
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setIsProvisional(bool in_opt_isProvisional)
    {
        JSON::ObjectBase::setBoolean("isProvisional"_s, in_opt_isProvisional);
    }

    void setIsPaused(bool in_opt_isPaused)
    {
        JSON::ObjectBase::setBoolean("isPaused"_s, in_opt_isPaused);
    }
};

} // Target

namespace Timeline {

/* Timeline record type. */
enum class EventType {
    EventDispatch = 211,
    ScheduleStyleRecalculation = 212,
    RecalculateStyles = 213,
    InvalidateLayout = 214,
    Layout = 215,
    Paint = 216,
    Composite = 217,
    RenderingFrame = 218,
    TimerInstall = 219,
    TimerRemove = 220,
    TimerFire = 221,
    EvaluateScript = 222,
    TimeStamp = 223,
    Time = 224,
    TimeEnd = 225,
    FunctionCall = 226,
    ProbeSample = 227,
    ConsoleProfile = 228,
    RequestAnimationFrame = 229,
    CancelAnimationFrame = 230,
    FireAnimationFrame = 231,
    ObserverCallback = 232,
}; // enum class EventType

/* Instrument types. */
enum class Instrument {
    ScriptProfiler = 233,
    Timeline = 234,
    CPU = 235,
    Memory = 236,
    Heap = 237,
    Animation = 238,
}; // enum class Instrument

/* Timeline record contains information about the recorded activity. */
class TimelineEvent final : public JSON::Object {
public:
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        DataSet = 1 << 1,
        AllFieldsSet = (TypeSet | DataSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*TimelineEvent*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class TimelineEvent;
    public:

        Builder<STATE | TypeSet>& setType(Protocol::Timeline::EventType in_type)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type"_s, Protocol::Helpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Builder<STATE | DataSet>& setData(Ref<JSON::Object>&& in_data)
        {
            COMPILE_ASSERT(!(STATE & DataSet), property_data_already_set);
            m_result->setObject("data"_s, WTFMove(in_data));
            return castState<DataSet>();
        }

        Ref<TimelineEvent> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(TimelineEvent) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<TimelineEvent>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<TimelineEvent> result = TimelineEvent::create()
     *     .setType(...)
     *     .setData(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setChildren(Ref<JSON::ArrayOf<Protocol::Timeline::TimelineEvent>>&& in_opt_children)
    {
        JSON::ObjectBase::setArray("children"_s, WTFMove(in_opt_children));
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* typeKey;
    JS_EXPORT_PRIVATE static const char* dataKey;
    JS_EXPORT_PRIVATE static const char* childrenKey;
};

} // Timeline

template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Debugger::Location> {
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Debugger::FunctionDetails> {
static Ref<Protocol::Debugger::FunctionDetails> runtimeCast(Ref<JSON::Value>&& value);
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Debugger::CallFrame> {
static Ref<Protocol::Debugger::CallFrame> runtimeCast(Ref<JSON::Value>&& value);
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Debugger::Scope> {
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Debugger::Scope::Type> {
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Runtime::RemoteObject> {
static Ref<Protocol::Runtime::RemoteObject> runtimeCast(Ref<JSON::Value>&& value);
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Runtime::RemoteObject::Type> {
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Runtime::RemoteObject::Subtype> {
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Runtime::ObjectPreview> {
static Ref<Protocol::Runtime::ObjectPreview> runtimeCast(Ref<JSON::Value>&& value);
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Runtime::ObjectPreview::Type> {
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Runtime::ObjectPreview::Subtype> {
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Runtime::PropertyPreview> {
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Runtime::PropertyPreview::Type> {
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Runtime::PropertyPreview::Subtype> {
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Runtime::EntryPreview> {
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Runtime::CollectionEntry> {
static Ref<Protocol::Runtime::CollectionEntry> runtimeCast(Ref<JSON::Value>&& value);
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Runtime::PropertyDescriptor> {
static Ref<Protocol::Runtime::PropertyDescriptor> runtimeCast(Ref<JSON::Value>&& value);
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Runtime::InternalPropertyDescriptor> {
static Ref<Protocol::Runtime::InternalPropertyDescriptor> runtimeCast(Ref<JSON::Value>&& value);
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Timeline::TimelineEvent> {
static Ref<Protocol::Timeline::TimelineEvent> runtimeCast(Ref<JSON::Value>&& value);
static void assertValueHasExpectedType(JSON::Value*);
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Protocol::Timeline::EventType> {
static void assertValueHasExpectedType(JSON::Value*);
};

namespace Helpers {

template<typename ProtocolEnumType>
Optional<ProtocolEnumType> parseEnumValueFromString(const String&);

// Enums in the 'Animation' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Animation::AnimationState> parseEnumValueFromString<Protocol::Animation::AnimationState>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Animation::PlaybackDirection> parseEnumValueFromString<Protocol::Animation::PlaybackDirection>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Animation::FillMode> parseEnumValueFromString<Protocol::Animation::FillMode>(const String&);

#if defined(ENABLE_RESOURCE_USAGE) && ENABLE_RESOURCE_USAGE
// Enums in the 'CPUProfiler' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::CPUProfiler::ThreadInfo::Type> parseEnumValueFromString<Protocol::CPUProfiler::ThreadInfo::Type>(const String&);
#endif // defined(ENABLE_RESOURCE_USAGE) && ENABLE_RESOURCE_USAGE

// Enums in the 'CSS' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::CSS::StyleSheetOrigin> parseEnumValueFromString<Protocol::CSS::StyleSheetOrigin>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::CSS::PseudoId> parseEnumValueFromString<Protocol::CSS::PseudoId>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::CSS::CSSPropertyStatus> parseEnumValueFromString<Protocol::CSS::CSSPropertyStatus>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::CSS::Grouping::Type> parseEnumValueFromString<Protocol::CSS::Grouping::Type>(const String&);

// Enums in the 'Canvas' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Canvas::ContextType> parseEnumValueFromString<Protocol::Canvas::ContextType>(const String&);
#if (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Canvas::ProgramType> parseEnumValueFromString<Protocol::Canvas::ProgramType>(const String&);
#endif // (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
#if (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Canvas::ShaderType> parseEnumValueFromString<Protocol::Canvas::ShaderType>(const String&);
#endif // (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)

// Enums in the 'Console' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Console::ChannelSource> parseEnumValueFromString<Protocol::Console::ChannelSource>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Console::ChannelLevel> parseEnumValueFromString<Protocol::Console::ChannelLevel>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Console::ConsoleMessage::Level> parseEnumValueFromString<Protocol::Console::ConsoleMessage::Level>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Console::ConsoleMessage::Type> parseEnumValueFromString<Protocol::Console::ConsoleMessage::Type>(const String&);

// Enums in the 'DOM' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::DOM::PseudoType> parseEnumValueFromString<Protocol::DOM::PseudoType>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::DOM::ShadowRootType> parseEnumValueFromString<Protocol::DOM::ShadowRootType>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::DOM::CustomElementState> parseEnumValueFromString<Protocol::DOM::CustomElementState>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::DOM::LiveRegionRelevant> parseEnumValueFromString<Protocol::DOM::LiveRegionRelevant>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::DOM::AccessibilityProperties::Checked> parseEnumValueFromString<Protocol::DOM::AccessibilityProperties::Checked>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::DOM::AccessibilityProperties::Current> parseEnumValueFromString<Protocol::DOM::AccessibilityProperties::Current>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::DOM::AccessibilityProperties::Invalid> parseEnumValueFromString<Protocol::DOM::AccessibilityProperties::Invalid>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::DOM::AccessibilityProperties::LiveRegionStatus> parseEnumValueFromString<Protocol::DOM::AccessibilityProperties::LiveRegionStatus>(const String&);

// Enums in the 'DOMDebugger' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::DOMDebugger::DOMBreakpointType> parseEnumValueFromString<Protocol::DOMDebugger::DOMBreakpointType>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::DOMDebugger::EventBreakpointType> parseEnumValueFromString<Protocol::DOMDebugger::EventBreakpointType>(const String&);

// Enums in the 'Debugger' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Debugger::BreakpointAction::Type> parseEnumValueFromString<Protocol::Debugger::BreakpointAction::Type>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Debugger::Scope::Type> parseEnumValueFromString<Protocol::Debugger::Scope::Type>(const String&);

// Enums in the 'Heap' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Heap::GarbageCollection::Type> parseEnumValueFromString<Protocol::Heap::GarbageCollection::Type>(const String&);

#if defined(ENABLE_INDEXED_DATABASE) && ENABLE_INDEXED_DATABASE
// Enums in the 'IndexedDB' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::IndexedDB::Key::Type> parseEnumValueFromString<Protocol::IndexedDB::Key::Type>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::IndexedDB::KeyPath::Type> parseEnumValueFromString<Protocol::IndexedDB::KeyPath::Type>(const String&);
#endif // defined(ENABLE_INDEXED_DATABASE) && ENABLE_INDEXED_DATABASE

#if defined(ENABLE_RESOURCE_USAGE) && ENABLE_RESOURCE_USAGE
// Enums in the 'Memory' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Memory::CategoryData::Type> parseEnumValueFromString<Protocol::Memory::CategoryData::Type>(const String&);
#endif // defined(ENABLE_RESOURCE_USAGE) && ENABLE_RESOURCE_USAGE

// Enums in the 'Network' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Network::NetworkStage> parseEnumValueFromString<Protocol::Network::NetworkStage>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Network::ResourceErrorType> parseEnumValueFromString<Protocol::Network::ResourceErrorType>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Network::Response::Source> parseEnumValueFromString<Protocol::Network::Response::Source>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Network::Metrics::Priority> parseEnumValueFromString<Protocol::Network::Metrics::Priority>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Network::Initiator::Type> parseEnumValueFromString<Protocol::Network::Initiator::Type>(const String&);

// Enums in the 'Page' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Page::Setting> parseEnumValueFromString<Protocol::Page::Setting>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Page::ResourceType> parseEnumValueFromString<Protocol::Page::ResourceType>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Page::CoordinateSystem> parseEnumValueFromString<Protocol::Page::CoordinateSystem>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Page::CookieSameSitePolicy> parseEnumValueFromString<Protocol::Page::CookieSameSitePolicy>(const String&);
#if (defined(ENABLE_DARK_MODE_CSS) && ENABLE_DARK_MODE_CSS) || (defined(HAVE_OS_DARK_MODE_SUPPORT) && HAVE_OS_DARK_MODE_SUPPORT)
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Page::Appearance> parseEnumValueFromString<Protocol::Page::Appearance>(const String&);
#endif // (defined(ENABLE_DARK_MODE_CSS) && ENABLE_DARK_MODE_CSS) || (defined(HAVE_OS_DARK_MODE_SUPPORT) && HAVE_OS_DARK_MODE_SUPPORT)

// Enums in the 'Recording' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Recording::Type> parseEnumValueFromString<Protocol::Recording::Type>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Recording::Initiator> parseEnumValueFromString<Protocol::Recording::Initiator>(const String&);

// Enums in the 'Runtime' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Runtime::ExecutionContextType> parseEnumValueFromString<Protocol::Runtime::ExecutionContextType>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Runtime::SyntaxErrorType> parseEnumValueFromString<Protocol::Runtime::SyntaxErrorType>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Runtime::RemoteObject::Type> parseEnumValueFromString<Protocol::Runtime::RemoteObject::Type>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Runtime::RemoteObject::Subtype> parseEnumValueFromString<Protocol::Runtime::RemoteObject::Subtype>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Runtime::ObjectPreview::Type> parseEnumValueFromString<Protocol::Runtime::ObjectPreview::Type>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Runtime::ObjectPreview::Subtype> parseEnumValueFromString<Protocol::Runtime::ObjectPreview::Subtype>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Runtime::PropertyPreview::Type> parseEnumValueFromString<Protocol::Runtime::PropertyPreview::Type>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Runtime::PropertyPreview::Subtype> parseEnumValueFromString<Protocol::Runtime::PropertyPreview::Subtype>(const String&);

// Enums in the 'ScriptProfiler' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::ScriptProfiler::EventType> parseEnumValueFromString<Protocol::ScriptProfiler::EventType>(const String&);

// Enums in the 'Target' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Target::TargetInfo::Type> parseEnumValueFromString<Protocol::Target::TargetInfo::Type>(const String&);

// Enums in the 'Timeline' Domain
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Timeline::EventType> parseEnumValueFromString<Protocol::Timeline::EventType>(const String&);
template<>
JS_EXPORT_PRIVATE Optional<Protocol::Timeline::Instrument> parseEnumValueFromString<Protocol::Timeline::Instrument>(const String&);

} // namespace Helpers

} // namespace Protocol

} // namespace Inspector

namespace WTF {

template<typename T> struct DefaultHash;

// Hash declarations in the 'Animation' Domain
template<>
struct DefaultHash<Inspector::Protocol::Animation::AnimationState> : IntHash<Inspector::Protocol::Animation::AnimationState> { };
template<>
struct DefaultHash<Inspector::Protocol::Animation::PlaybackDirection> : IntHash<Inspector::Protocol::Animation::PlaybackDirection> { };
template<>
struct DefaultHash<Inspector::Protocol::Animation::FillMode> : IntHash<Inspector::Protocol::Animation::FillMode> { };

// Hash declarations in the 'CSS' Domain
template<>
struct DefaultHash<Inspector::Protocol::CSS::StyleSheetOrigin> : IntHash<Inspector::Protocol::CSS::StyleSheetOrigin> { };
template<>
struct DefaultHash<Inspector::Protocol::CSS::PseudoId> : IntHash<Inspector::Protocol::CSS::PseudoId> { };
template<>
struct DefaultHash<Inspector::Protocol::CSS::CSSPropertyStatus> : IntHash<Inspector::Protocol::CSS::CSSPropertyStatus> { };

// Hash declarations in the 'Canvas' Domain
template<>
struct DefaultHash<Inspector::Protocol::Canvas::ContextType> : IntHash<Inspector::Protocol::Canvas::ContextType> { };
#if (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
template<>
struct DefaultHash<Inspector::Protocol::Canvas::ProgramType> : IntHash<Inspector::Protocol::Canvas::ProgramType> { };
#endif // (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
#if (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)
template<>
struct DefaultHash<Inspector::Protocol::Canvas::ShaderType> : IntHash<Inspector::Protocol::Canvas::ShaderType> { };
#endif // (defined(ENABLE_WEBGL) && ENABLE_WEBGL) || (defined(ENABLE_WEBGPU) && ENABLE_WEBGPU)

// Hash declarations in the 'Console' Domain
template<>
struct DefaultHash<Inspector::Protocol::Console::ChannelSource> : IntHash<Inspector::Protocol::Console::ChannelSource> { };
template<>
struct DefaultHash<Inspector::Protocol::Console::ChannelLevel> : IntHash<Inspector::Protocol::Console::ChannelLevel> { };

// Hash declarations in the 'DOM' Domain
template<>
struct DefaultHash<Inspector::Protocol::DOM::PseudoType> : IntHash<Inspector::Protocol::DOM::PseudoType> { };
template<>
struct DefaultHash<Inspector::Protocol::DOM::ShadowRootType> : IntHash<Inspector::Protocol::DOM::ShadowRootType> { };
template<>
struct DefaultHash<Inspector::Protocol::DOM::CustomElementState> : IntHash<Inspector::Protocol::DOM::CustomElementState> { };
template<>
struct DefaultHash<Inspector::Protocol::DOM::LiveRegionRelevant> : IntHash<Inspector::Protocol::DOM::LiveRegionRelevant> { };

// Hash declarations in the 'DOMDebugger' Domain
template<>
struct DefaultHash<Inspector::Protocol::DOMDebugger::DOMBreakpointType> : IntHash<Inspector::Protocol::DOMDebugger::DOMBreakpointType> { };
template<>
struct DefaultHash<Inspector::Protocol::DOMDebugger::EventBreakpointType> : IntHash<Inspector::Protocol::DOMDebugger::EventBreakpointType> { };

// Hash declarations in the 'Network' Domain
template<>
struct DefaultHash<Inspector::Protocol::Network::NetworkStage> : IntHash<Inspector::Protocol::Network::NetworkStage> { };
template<>
struct DefaultHash<Inspector::Protocol::Network::ResourceErrorType> : IntHash<Inspector::Protocol::Network::ResourceErrorType> { };

// Hash declarations in the 'Page' Domain
template<>
struct DefaultHash<Inspector::Protocol::Page::Setting> : IntHash<Inspector::Protocol::Page::Setting> { };
template<>
struct DefaultHash<Inspector::Protocol::Page::ResourceType> : IntHash<Inspector::Protocol::Page::ResourceType> { };
template<>
struct DefaultHash<Inspector::Protocol::Page::CoordinateSystem> : IntHash<Inspector::Protocol::Page::CoordinateSystem> { };
template<>
struct DefaultHash<Inspector::Protocol::Page::CookieSameSitePolicy> : IntHash<Inspector::Protocol::Page::CookieSameSitePolicy> { };
#if (defined(ENABLE_DARK_MODE_CSS) && ENABLE_DARK_MODE_CSS) || (defined(HAVE_OS_DARK_MODE_SUPPORT) && HAVE_OS_DARK_MODE_SUPPORT)
template<>
struct DefaultHash<Inspector::Protocol::Page::Appearance> : IntHash<Inspector::Protocol::Page::Appearance> { };
#endif // (defined(ENABLE_DARK_MODE_CSS) && ENABLE_DARK_MODE_CSS) || (defined(HAVE_OS_DARK_MODE_SUPPORT) && HAVE_OS_DARK_MODE_SUPPORT)

// Hash declarations in the 'Recording' Domain
template<>
struct DefaultHash<Inspector::Protocol::Recording::Type> : IntHash<Inspector::Protocol::Recording::Type> { };
template<>
struct DefaultHash<Inspector::Protocol::Recording::Initiator> : IntHash<Inspector::Protocol::Recording::Initiator> { };

// Hash declarations in the 'Runtime' Domain
template<>
struct DefaultHash<Inspector::Protocol::Runtime::ExecutionContextType> : IntHash<Inspector::Protocol::Runtime::ExecutionContextType> { };
template<>
struct DefaultHash<Inspector::Protocol::Runtime::SyntaxErrorType> : IntHash<Inspector::Protocol::Runtime::SyntaxErrorType> { };

// Hash declarations in the 'ScriptProfiler' Domain
template<>
struct DefaultHash<Inspector::Protocol::ScriptProfiler::EventType> : IntHash<Inspector::Protocol::ScriptProfiler::EventType> { };

// Hash declarations in the 'Timeline' Domain
template<>
struct DefaultHash<Inspector::Protocol::Timeline::EventType> : IntHash<Inspector::Protocol::Timeline::EventType> { };
template<>
struct DefaultHash<Inspector::Protocol::Timeline::Instrument> : IntHash<Inspector::Protocol::Timeline::Instrument> { };

} // namespace WTF
